{"version":3,"file":"gzip-worker.js","sources":["../../node_modules/pako/lib/zlib/trees.js","../../node_modules/pako/lib/zlib/deflate.js","../../node_modules/pako/lib/utils/strings.js","../../node_modules/pako/lib/deflate.js","../../node_modules/pako/lib/utils/common.js","../../node_modules/pako/lib/zlib/adler32.js","../../node_modules/pako/lib/zlib/crc32.js","../../node_modules/pako/lib/zlib/messages.js","../../node_modules/pako/lib/zlib/zstream.js","../../src/js/gzip-worker/index.js"],"sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","import {gzip} from 'pako/lib/deflate';\r\n\r\nself.onmessage = function(event) {\r\n  try {\r\n    var result = gzip(event.data.data).buffer;\r\n    self.postMessage({\r\n      id: event.data.id,\r\n      result: result\r\n    });\r\n  }\r\n  catch (error) {\r\n    self.postMessage({\r\n      id: event.data.id,\r\n      error: error.message\r\n    });\r\n  }\r\n};"],"names":["length","static_tree","extra_bits","extra_base","elems","max_length","has_stree","dyn_tree","max_code","stat_desc","pending_buf","pending","bi_valid","bi_buf","bl_count","heap","heap_max","opt_len","static_len","Array","MAX_BITS","LENGTH_CODES","L_CODES","LITERALS","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","utils","arraySet","window","heap_len","depth","d_buf","l_buf","l_desc","d_desc","bl_desc","BL_CODES","msg","state","avail_out","output","pending_out","next_out","total_out","_tr_flush_block","block_start","strstart","strm","avail_in","input","next_in","wrap","adler","adler32","crc32","total_in","max_chain_length","prev_length","nice_match","w_size","w_mask","prev","good_match","lookahead","match_start","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","match_length","_tr_tally","max_lazy_match","prev_match","strategy","match_available","good_length","max_lazy","nice_length","max_chain","func","level","status","pending_buf_size","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Buf16","lit_bufsize","data_type","_tr_init","Buf8","subarray","apply","shrinkBuf","options","assign","chunkSize","windowBits","memLevel","to","raw","gzip","err","ended","chunks","zlib_deflate","deflateInit2","Error","header","deflateSetHeader","dictionary","string2buf","call","Uint8Array","deflateSetDictionary","_dict_set","push","result","String","fromCharCode","Object","prototype","hasOwnProperty","Uint16Array","Int32Array","slice","arguments","shift","TypeError","set","flattenChunks","concat","setTyped","D_CODES","HEAP_SIZE","zero","MAX_MATCH","Z_NO_FLUSH","Z_FINISH","Z_OK","Z_STREAM_END","Z_DEFAULT_COMPRESSION","Z_DEFLATED","text","hcrc","extra","name","comment","time","os","charCodeAt","_tr_align","_tr_stored_block","toString","deflate","onEnd","onData","buf2binstring","deflateEnd","join","self","onmessage","data","buffer","postMessage","id","error","message"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIkM6L1VzZXJzL0suSG9uZGEvRG9jdW1lbnRzL0dpdEh1Yi9zdmdvbWcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJDOi9Vc2Vycy9LLkhvbmRhL0RvY3VtZW50cy9HaXRIdWIvc3Znb21nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJDOi9Vc2Vycy9LLkhvbmRhL0RvY3VtZW50cy9HaXRIdWIvc3Znb21nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwiQzovVXNlcnMvSy5Ib25kYS9Eb2N1bWVudHMvR2l0SHViL3N2Z29tZy9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIkM6L1VzZXJzL0suSG9uZGEvRG9jdW1lbnRzL0dpdEh1Yi9zdmdvbWcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIkM6L1VzZXJzL0suSG9uZGEvRG9jdW1lbnRzL0dpdEh1Yi9zdmdvbWcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIkM6L1VzZXJzL0suSG9uZGEvRG9jdW1lbnRzL0dpdEh1Yi9zdmdvbWcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJDOi9Vc2Vycy9LLkhvbmRhL0RvY3VtZW50cy9HaXRIdWIvc3Znb21nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwiQzovVXNlcnMvSy5Ib25kYS9Eb2N1bWVudHMvR2l0SHViL3N2Z29tZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwiQzovVXNlcnMvSy5Ib25kYS9Eb2N1bWVudHMvR2l0SHViL3N2Z29tZy9zcmMvanMvZ3ppcC13b3JrZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyB1c2UgZmFsbGJhY2sgZm9yIGJpZyBhcnJheXMgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3dcbiAgaWYgKGxlbiA8IDY1NTM3KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgnLi96bGliL2RlZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xuXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG5cbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pICBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICB2YXIgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tEZWZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogYXJyYXkgZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKFpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCJpbXBvcnQge2d6aXB9IGZyb20gJ3Bha28vbGliL2RlZmxhdGUnO1xyXG5cclxuc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZ3ppcChldmVudC5kYXRhLmRhdGEpLmJ1ZmZlcjtcclxuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICBpZDogZXZlbnQuZGF0YS5pZCxcclxuICAgICAgcmVzdWx0OiByZXN1bHRcclxuICAgIH0pO1xyXG4gIH1cclxuICBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICBpZDogZXZlbnQuZGF0YS5pZCxcclxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcclxuICAgIH0pO1xyXG4gIH1cclxufTsiXSwibmFtZXMiOlsibGVuZ3RoIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsImR5bl90cmVlIiwibWF4X2NvZGUiLCJzdGF0X2Rlc2MiLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmciLCJiaV92YWxpZCIsImJpX2J1ZiIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbWF4Iiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJBcnJheSIsIk1BWF9CSVRTIiwiTEVOR1RIX0NPREVTIiwiTF9DT0RFUyIsIkxJVEVSQUxTIiwiZHluX2x0cmVlIiwiZHluX2R0cmVlIiwiYmxfdHJlZSIsImxhc3RfbGl0IiwibWF0Y2hlcyIsInV0aWxzIiwiYXJyYXlTZXQiLCJ3aW5kb3ciLCJoZWFwX2xlbiIsImRlcHRoIiwiZF9idWYiLCJsX2J1ZiIsImxfZGVzYyIsImRfZGVzYyIsImJsX2Rlc2MiLCJCTF9DT0RFUyIsIm1zZyIsInN0YXRlIiwiYXZhaWxfb3V0Iiwib3V0cHV0IiwicGVuZGluZ19vdXQiLCJuZXh0X291dCIsInRvdGFsX291dCIsIl90cl9mbHVzaF9ibG9jayIsImJsb2NrX3N0YXJ0Iiwic3Ryc3RhcnQiLCJzdHJtIiwiYXZhaWxfaW4iLCJpbnB1dCIsIm5leHRfaW4iLCJ3cmFwIiwiYWRsZXIiLCJhZGxlcjMyIiwiY3JjMzIiLCJ0b3RhbF9pbiIsIm1heF9jaGFpbl9sZW5ndGgiLCJwcmV2X2xlbmd0aCIsIm5pY2VfbWF0Y2giLCJ3X3NpemUiLCJ3X21hc2siLCJwcmV2IiwiZ29vZF9tYXRjaCIsImxvb2thaGVhZCIsIm1hdGNoX3N0YXJ0Iiwid2luZG93X3NpemUiLCJoYXNoX3NpemUiLCJoZWFkIiwiaW5zZXJ0IiwiaW5zX2giLCJoYXNoX3NoaWZ0IiwiaGFzaF9tYXNrIiwibWF0Y2hfbGVuZ3RoIiwiX3RyX3RhbGx5IiwibWF4X2xhenlfbWF0Y2giLCJwcmV2X21hdGNoIiwic3RyYXRlZ3kiLCJtYXRjaF9hdmFpbGFibGUiLCJnb29kX2xlbmd0aCIsIm1heF9sYXp5IiwibmljZV9sZW5ndGgiLCJtYXhfY2hhaW4iLCJmdW5jIiwibGV2ZWwiLCJzdGF0dXMiLCJwZW5kaW5nX2J1Zl9zaXplIiwiZ3poZWFkIiwiZ3ppbmRleCIsIm1ldGhvZCIsImxhc3RfZmx1c2giLCJ3X2JpdHMiLCJoYXNoX2JpdHMiLCJCdWYxNiIsImxpdF9idWZzaXplIiwiZGF0YV90eXBlIiwiX3RyX2luaXQiLCJCdWY4Iiwic3ViYXJyYXkiLCJhcHBseSIsInNocmlua0J1ZiIsIm9wdGlvbnMiLCJhc3NpZ24iLCJjaHVua1NpemUiLCJ3aW5kb3dCaXRzIiwibWVtTGV2ZWwiLCJ0byIsInJhdyIsImd6aXAiLCJlcnIiLCJlbmRlZCIsImNodW5rcyIsInpsaWJfZGVmbGF0ZSIsImRlZmxhdGVJbml0MiIsIkVycm9yIiwiaGVhZGVyIiwiZGVmbGF0ZVNldEhlYWRlciIsImRpY3Rpb25hcnkiLCJzdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsIl9kaWN0X3NldCIsInB1c2giLCJyZXN1bHQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwic2hpZnQiLCJUeXBlRXJyb3IiLCJzZXQiLCJmbGF0dGVuQ2h1bmtzIiwiY29uY2F0Iiwic2V0VHlwZWQiLCJEX0NPREVTIiwiSEVBUF9TSVpFIiwiemVybyIsIk1BWF9NQVRDSCIsIlpfTk9fRkxVU0giLCJaX0ZJTklTSCIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkxBVEVEIiwidGV4dCIsImhjcmMiLCJleHRyYSIsIm5hbWUiLCJjb21tZW50IiwidGltZSIsIm9zIiwiY2hhckNvZGVBdCIsIl90cl9hbGlnbiIsIl90cl9zdG9yZWRfYmxvY2siLCJ0b1N0cmluZyIsImRlZmxhdGUiLCJvbkVuZCIsIm9uRGF0YSIsImJ1ZjJiaW5zdHJpbmciLCJkZWZsYXRlRW5kIiwiam9pbiIsInNlbGYiLCJvbm1lc3NhZ2UiLCJkYXRhIiwiYnVmZmVyIiwicG9zdE1lc3NhZ2UiLCJpZCIsImVycm9yIiwibWVzc2FnZSJdLCJtYXBwaW5ncyI6InlCQTBDQSxhQUFtQixLQUFFLEdBQUksR0FBTSxFQUFJQSxNQUFoQixDQUF3QyxDQUFULEtBQS9CLEVBQTZDLEtBQVcsQ0FBTSxDQTJIakYscUJBQWdGLENBRTlFLEtBQUtDLFdBQUwsRUFGOEUsQ0FHOUUsS0FBS0MsVUFBTCxFQUg4RSxDQUk5RSxLQUFLQyxVQUFMLEVBSjhFLENBSzlFLEtBQUtDLEtBQUwsRUFMOEUsQ0FNOUUsS0FBS0MsVUFBTCxFQU44RSxDQVM5RSxLQUFLQyxTQUFMLENBQW9CLEdBQWUsRUFBWU4sTUFDaEQsQ0FRRCxlQUF1QyxDQUNyQyxLQUFLTyxRQUFMLEVBRHFDLENBRXJDLEtBQUtDLFFBQUwsQ0FBZ0IsQ0FGcUIsQ0FHckMsS0FBS0MsU0FBTCxFQUNELENBSUQsYUFBc0IsQ0FDcEIsTUFBYyxJQUFQLEdBQWEsS0FBYixDQUFnQyxHQUFXLEtBQU8sSUFBUyxDQUFoQixDQUFYLENBQ3hDLENBT0QsZUFBeUIsQ0FHdkIsRUFBRUMsV0FBRixDQUFjLEVBQUVDLE9BQUYsRUFBZCxFQUFtQyxHQUFOLEVBSE4sQ0FJdkIsRUFBRUQsV0FBRixDQUFjLEVBQUVDLE9BQUYsRUFBZCxFQUF5QyxHQUFaLENBQUMsSUFBTSxDQUNyQyxDQU9ELGlCQUFxQyxDQUMvQixFQUFFQyxRQUFGLENBQWMsSUFEaUIsRUFFakMsRUFBRUMsTUFBRixFQUFvQyxLQUF4QixDQUFDLEdBQVMsRUFBRUQsUUFGUyxDQUdqQyxJQUFhLEVBQUVDLE1BQWYsQ0FIaUMsQ0FJakMsRUFBRUEsTUFBRixDQUFXLEdBQVUsR0FBVyxFQUFFRCxRQUpELENBS2pDLEVBQUVBLFFBQUYsRUFBYyxJQUxtQixHQU9qQyxFQUFFQyxNQUFGLEVBQW9DLEtBQXhCLENBQUMsR0FBUyxFQUFFRCxRQVBTLENBUWpDLEVBQUVBLFFBQUYsR0FSaUMsQ0FVcEMsQ0FHRCxpQkFBK0IsQ0FDN0IsSUFBYSxFQUFTLENBQUosRUFBTCxDQUFiLENBQW1DLEVBQVMsQ0FBSixHQUFRLENBQWIsQ0FBbkMsQ0FDRCxDQVFELGVBQStCLENBQzdCLEdBQUksR0FBTSxDQUFWLENBQ0EsRUFDRSxJQUFjLENBQVAsRUFEVCxDQUVFLEtBQVUsQ0FGWixDQUdFLElBQVEsQ0FIVixPQUlpQixDQUFSLElBSlQsRUFLQSxNQUFPLEtBQVEsQ0FDaEIsQ0FNRCxhQUFxQixDQUNBLEVBQWYsS0FBRUEsUUFEYSxFQUVqQixJQUFhLEVBQUVDLE1BQWYsQ0FGaUIsQ0FHakIsRUFBRUEsTUFBRixDQUFXLENBSE0sQ0FJakIsRUFBRUQsUUFBRixDQUFhLENBSkksRUFNTSxDQUFkLElBQUVBLFFBTk0sR0FPakIsRUFBRUYsV0FBRixDQUFjLEVBQUVDLE9BQUYsRUFBZCxFQUF3QyxHQUFYLEdBQUVFLE1BUGQsQ0FRakIsRUFBRUEsTUFBRixHQUFhLENBUkksQ0FTakIsRUFBRUQsUUFBRixFQUFjLENBVEcsQ0FXcEIsQ0FhRCxlQUdBLElBUU0sRUFSTixDQVNNLENBVE4sQ0FTUyxDQVRULENBVU0sQ0FWTixDQVdNLENBWE4sQ0FZTSxDQVpOLENBQ00sRUFBa0IsRUFBS0wsUUFEN0IsQ0FFTSxFQUFrQixFQUFLQyxRQUY3QixDQUdNLEVBQWtCLEVBQUtDLFNBQUwsQ0FBZVIsV0FIdkMsQ0FJTSxFQUFrQixFQUFLUSxTQUFMLENBQWVILFNBSnZDLENBS00sRUFBa0IsRUFBS0csU0FBTCxDQUFlUCxVQUx2QyxDQU1NLEVBQWtCLEVBQUtPLFNBQUwsQ0FBZU4sVUFOdkMsQ0FPTSxFQUFrQixFQUFLTSxTQUFMLENBQWVKLFVBUHZDLENBYU0sRUFBVyxDQWJqQixDQWVFLElBQUssRUFBTyxDQUFaLENBQWUsS0FBZixDQUFpQyxHQUFqQyxDQUNFLEVBQUVTLFFBQUYsSUFBbUIsQ0FBbkIsQ0FRRixJQUZBLEVBQTBCLENBQXJCLEdBQUVDLElBQUYsQ0FBTyxFQUFFQyxRQUFULEVBQXlCLENBQTlCLEVBQTJDLENBRTNDLENBQUssRUFBSSxFQUFFQSxRQUFGLENBQWEsQ0FBdEIsQ0FBeUIsSUFBekIsQ0FBd0MsR0FBeEMsRUFDRSxFQUFJLEVBQUVELElBQUYsR0FETixDQUVFLEVBQU8sRUFBK0IsQ0FBMUIsR0FBUyxDQUFKLEdBQVEsQ0FBYixFQUE4QixDQUFuQyxFQUFnRCxDQUZ6RCxDQUdNLEdBSE4sR0FJSSxHQUpKLENBS0ksR0FMSixFQU9FLEVBQVMsQ0FBSixHQUFRLENBQWIsR0FQRixHQVVNLEdBVk4sS0FZRSxFQUFFRCxRQUFGLEtBWkYsQ0FhRSxFQUFRLENBYlYsQ0FjTSxJQWROLEdBZUksRUFBUSxFQUFNLEdBQU4sQ0FmWixFQWlCRSxFQUFJLEVBQVMsQ0FBSixFQUFMLENBakJOLENBa0JFLEVBQUVHLE9BQUYsRUFBYSxHQUFLLEdBQUwsQ0FsQmYsS0FvQkksRUFBRUMsVUFBRixFQUFnQixHQUFLLEVBQVUsQ0FBSixHQUFRLENBQWQsR0FBTCxDQXBCcEIsR0F1QkEsR0FBaUIsQ0FBYixHQUFKLEVBTUEsRUFBRyxLQUNELEVBQU8sRUFBYSxDQURuQixDQUUyQixDQUFyQixLQUFFSixRQUFGLEdBRk4sRUFFZ0MsSUFDakMsRUFBRUEsUUFBRixLQUhDLENBSUQsRUFBRUEsUUFBRixDQUFXLEVBQU8sQ0FBbEIsR0FBd0IsQ0FKdkIsQ0FLRCxFQUFFQSxRQUFGLEtBTEMsQ0FTRCxHQUFZLENBQ2IsQ0FWRCxNQVVvQixDQUFYLEVBVlQsRUFpQkEsSUFBSyxHQUFMLENBQWlDLENBQVQsSUFBeEIsQ0FBb0MsR0FBcEMsS0FDRSxFQUFJLEVBQUVBLFFBQUYsR0FETixDQUVlLENBQU4sSUFGVCxHQUdJLEVBQUksRUFBRUMsSUFBRixDQUFPLEdBQVAsQ0FIUixHQUlRLEdBSlIsS0FLUSxFQUFTLENBQUosR0FBUSxDQUFiLEtBTFIsR0FPTSxFQUFFRSxPQUFGLEVBQWEsQ0FBQyxFQUFPLEVBQVMsQ0FBSixHQUFRLENBQWIsQ0FBUixFQUFtQyxFQUFTLENBQUosRUFBTCxDQVB0RCxDQVFNLEVBQVMsQ0FBSixHQUFRLENBQWIsR0FSTixFQVVJLEdBVkosQ0F2QkEsQ0FvQ0QsQ0FXRCxpQkFJQSxJQUdNLEVBSE4sQ0FJTSxDQUpOLENBQ00sRUFBZ0JFLEtBQWhCLENBQXNCQyxHQUFXLENBQWpDLENBRE4sQ0FFTSxFQUFPLENBRmIsQ0FTRSxJQUFLLEVBQU8sQ0FBWixDQUFlLEtBQWYsQ0FBaUMsR0FBakMsQ0FDRSxLQUFrQixFQUFRLEVBQU8sRUFBUyxFQUFPLENBQWhCLENBQVIsRUFBK0IsQ0FBeEQsQ0FTRixJQUFLLEVBQUksQ0FBVCxDQUFhLElBQWIsQ0FBNEIsR0FBNUIsQ0FBaUMsQ0FDL0IsR0FBSSxHQUFNLEVBQVMsQ0FBSixHQUFRLENBQWIsQ0FBVixDQUNZLENBQVIsSUFGMkIsR0FJL0IsRUFBUyxDQUFKLEVBQUwsRUFBdUIsRUFBVyxNQUFYLEdBSlEsQ0FRaEMsQ0FDRixDQU1ELFlBQTBCLElBQ3BCLEVBRG9CLENBRXBCLENBRm9CLENBR3BCLENBSG9CLENBSXBCLENBSm9CLENBS3BCLENBTG9CLENBTXBCLEVBQWVELEtBQWYsQ0FBcUJDLEdBQVcsQ0FBaEMsQ0FOb0IsQ0F1QnhCLElBREEsRUFBUyxDQUNULENBQUssRUFBTyxDQUFaLENBQWUsRUFBT0MsR0FBZSxDQUFyQyxDQUF3QyxHQUF4QyxDQUVFLElBREEsT0FDQSxDQUFLLEVBQUksQ0FBVCxDQUFZLEVBQUssR0FBSyxLQUF0QixDQUEwQyxHQUExQyxDQUNFLEdBQWEsR0FBYixJQVlKLElBSkEsR0FBYSxFQUFTLENBQXRCLEdBSUEsQ0FEQSxFQUFPLENBQ1AsQ0FBSyxFQUFPLENBQVosQ0FBc0IsRUFBUCxFQUFmLENBQTBCLEdBQTFCLENBRUUsSUFEQSxPQUNBLENBQUssRUFBSSxDQUFULENBQVksRUFBSyxHQUFLLEtBQXRCLENBQTBDLEdBQTFDLENBQ0UsR0FBVyxHQUFYLElBS0osSUFEQSxJQUFTLENBQ1QsQ0FBTyxJQUFQLENBQXVCLEdBQXZCLENBRUUsSUFEQSxNQUFrQixHQUFRLENBQzFCLENBQUssRUFBSSxDQUFULENBQVksRUFBSyxHQUFNLE1BQW9CLENBQTNDLENBQWdELEdBQWhELENBQ0UsR0FBVyxJQUFNLEdBQWpCLElBTUosSUFBSyxFQUFPLENBQVosQ0FBZSxLQUFmLENBQWlDLEdBQWpDLENBQ0UsS0FBaUIsQ0FBakIsQ0F4RHNCLElBMkR4QixFQUFJLENBM0RvQixDQTREWixHQUFMLEdBNURpQixFQTZEdEIsR0FBaUIsQ0FBSixHQUFRLENBQXJCLEVBQWtDLENBN0RaLENBOER0QixHQTlEc0IsQ0ErRHRCLEVBQVMsQ0FBVCxHQS9Ec0IsTUFpRVosR0FBTCxHQWpFaUIsRUFrRXRCLEdBQWlCLENBQUosR0FBUSxDQUFyQixFQUFrQyxDQWxFWixDQW1FdEIsR0FuRXNCLENBb0V0QixFQUFTLENBQVQsR0FwRXNCLE1Bc0VaLEdBQUwsR0F0RWlCLEVBdUV0QixHQUFpQixDQUFKLEdBQVEsQ0FBckIsRUFBa0MsQ0F2RVosQ0F3RXRCLEdBeEVzQixDQXlFdEIsRUFBUyxDQUFULEdBekVzQixNQTJFWixHQUFMLEdBM0VpQixFQTRFdEIsR0FBaUIsQ0FBSixHQUFRLENBQXJCLEVBQWtDLENBNUVaLENBNkV0QixHQTdFc0IsQ0E4RXRCLEVBQVMsQ0FBVCxHQTlFc0IsQ0F1RnhCLElBSEEsS0FBd0JDLEdBQVUsQ0FBbEMsR0FHQSxDQUFLLEVBQUksQ0FBVCxDQUFZLElBQVosQ0FBeUIsR0FBekIsQ0FDRSxHQUFpQixDQUFKLEdBQVEsQ0FBckIsRUFBa0MsQ0FEcEMsQ0FFRSxHQUFpQixDQUFKLEVBQWIsRUFBK0IsSUFBYyxDQUFkLENBRmpDLENBTUEsR0FBZ0IsWUFBOENDLEdBQVcsQ0FBekQsT0E3RlEsQ0E4RnhCLEdBQWdCLFlBQThDLENBQTlDLE9BOUZRLENBK0Z4QixHQUFpQixZQUErQyxDQUEvQyxPQUdsQixDQU1ELGFBQXVCLENBQ3JCLEdBQUksRUFBSixDQUdBLElBQUssRUFBSSxDQUFULENBQVksSUFBWixDQUEwQixHQUExQixDQUFpQyxFQUFFQyxTQUFGLENBQWdCLENBQUosRUFBWixFQUE4QixDQUE5QixDQUNqQyxJQUFLLEVBQUksQ0FBVCxDQUFZLElBQVosQ0FBMEIsR0FBMUIsQ0FBaUMsRUFBRUMsU0FBRixDQUFnQixDQUFKLEVBQVosRUFBOEIsQ0FBOUIsQ0FDakMsSUFBSyxFQUFJLENBQVQsQ0FBWSxJQUFaLENBQTBCLEdBQTFCLENBQWlDLEVBQUVDLE9BQUYsQ0FBYyxDQUFKLEVBQVYsRUFBNEIsQ0FBNUIsQ0FFakMsRUFBRUYsU0FBRixDQUF3QixDQUFaLEdBQVosRUFBc0MsQ0FSakIsQ0FTckIsRUFBRVAsT0FBRixDQUFZLEVBQUVDLFVBQUYsQ0FBZSxDQVROLENBVXJCLEVBQUVTLFFBQUYsQ0FBYSxFQUFFQyxPQUFGLENBQVksQ0FDMUIsQ0FNRCxhQUNBLENBQ21CLENBQWIsR0FBRWhCLFFBRFIsQ0FFSSxJQUFhLEVBQUVDLE1BQWYsQ0FGSixDQUcwQixDQUFiLEdBQUVELFFBSGYsR0FLSSxFQUFFRixXQUFGLENBQWMsRUFBRUMsT0FBRixFQUFkLEVBQTZCLEVBQUVFLE1BTG5DLEVBT0UsRUFBRUEsTUFBRixDQUFXLENBUGIsQ0FRRSxFQUFFRCxRQUFGLENBQWEsQ0FDZCxDQU1ELG1CQUtBLENBQ0UsSUFERixLQUlJLE1BSkosQ0FLSSxJQUFhLEVBQWIsQ0FMSixFQVVFaUIsRUFBTUMsUUFBTkQsQ0FBZSxFQUFFbkIsV0FBakJtQixDQUE4QixFQUFFRSxNQUFoQ0YsS0FBa0QsRUFBRWxCLE9BQXBEa0IsQ0FWRixDQVdFLEVBQUVsQixPQUFGLEdBQ0QsQ0FNRCxtQkFBb0MsSUFDOUIsR0FBVSxDQUFKLEVBRHdCLENBRTlCLEVBQVUsQ0FBSixFQUZ3QixDQUdsQyxNQUFRLE1BQXFCLElBQXJCLEVBQ0EsT0FBdUIsSUFBdkIsRUFBNkMsTUFBWSxJQUNsRSxDQVFELGlCQUlBLFFBQ00sR0FBSSxFQUFFSSxJQUFGLEdBRFYsQ0FFTSxFQUFJLEdBQUssQ0FGZixDQUdTLEdBQUssRUFBRWlCLFFBSGhCLEdBS1EsRUFBSSxFQUFFQSxRQUFOLEVBQ0YsSUFBYyxFQUFFakIsSUFBRixDQUFPLEVBQUksQ0FBWCxDQUFkLENBQTZCLEVBQUVBLElBQUYsR0FBN0IsQ0FBd0MsRUFBRWtCLEtBQTFDLENBTk4sRUFPTSxHQVBOLEVBVVEsTUFBaUIsRUFBRWxCLElBQUYsR0FBakIsQ0FBNEIsRUFBRWtCLEtBQTlCLENBVlIsR0FhSSxFQUFFbEIsSUFBRixJQUFZLEVBQUVBLElBQUYsR0FiaEIsQ0FjSSxHQWRKLENBaUJJLElBQU0sQ0FqQlYsQ0FtQkUsRUFBRUEsSUFBRixLQUNELENBU0QsaUJBSUEsSUFDTSxFQUROLENBRU0sQ0FGTixDQUlNLENBSk4sQ0FLTSxDQUxOLENBR00sRUFBSyxDQUhYLENBT0UsR0FBbUIsQ0FBZixLQUFFWSxRQUFOLENBQ0UsRUFDRSxHQUFRLEVBQUVqQixXQUFGLENBQWMsRUFBRXdCLEtBQUYsQ0FBZSxDQUFMLEVBQXhCLEdBQW1DLENBQXBDLENBQTBDLEVBQUV4QixXQUFGLENBQWMsRUFBRXdCLEtBQUYsQ0FBZSxDQUFMLEVBQVYsQ0FBbUIsQ0FBakMsQ0FEbkQsQ0FFRSxFQUFLLEVBQUV4QixXQUFGLENBQWMsRUFBRXlCLEtBQUYsRUFBZCxDQUZQLENBR0UsR0FIRixDQUtlLENBQVQsSUFMTixDQU1JLFFBTkosRUFVSSxFQUFPLEtBVlgsQ0FXSSxJQUFhLEtBQWtCLENBQS9CLEdBWEosQ0FZSSxFQUFRLEtBWlosQ0Fha0IsQ0FBVixJQWJSLEdBY00sR0FBTSxLQWRaLENBZU0sUUFmTixFQWlCSSxHQWpCSixDQWtCSSxFQUFPLElBbEJYLENBcUJJLFFBckJKLENBc0JJLEVBQVEsS0F0QlosQ0F1QmtCLENBQVYsSUF2QlIsR0F3Qk0sR0FBUSxLQXhCZCxDQXlCTSxRQXpCTixTQWlDUyxFQUFLLEVBQUVSLFFBakNoQixFQW9DRixTQUNELENBV0QsZUFHQSxJQUtNLEVBTE4sQ0FLUyxDQUxULENBT00sQ0FQTixDQUNNLEVBQVcsRUFBS3BCLFFBRHRCLENBRU0sRUFBVyxFQUFLRSxTQUFMLENBQWVSLFdBRmhDLENBR00sRUFBWSxFQUFLUSxTQUFMLENBQWVILFNBSGpDLENBSU0sRUFBVyxFQUFLRyxTQUFMLENBQWVMLEtBSmhDLENBTU0sRUFBVyxDQUFDLENBTmxCLENBZ0JFLElBSEEsRUFBRTRCLFFBQUYsQ0FBYSxDQUdiLENBRkEsRUFBRWhCLFFBQUYsR0FFQSxDQUFLLEVBQUksQ0FBVCxDQUFZLEdBQVosQ0FBdUIsR0FBdkIsQ0FDK0IsQ0FBekIsS0FBUyxDQUFKLEVBQUwsQ0FETixDQU1JLEVBQVMsQ0FBSixHQUFRLENBQWIsRUFBMEIsQ0FOOUIsRUFFSSxFQUFFRCxJQUFGLENBQU8sRUFBRSxFQUFFaUIsUUFBWCxFQUF1QixHQUYzQixDQUdJLEVBQUVDLEtBQUYsSUFBYSxDQUhqQixFQWhCRixLQStCc0IsQ0FBYixHQUFFRCxRQS9CWCxFQWdDSSxFQUFPLEVBQUVqQixJQUFGLENBQU8sRUFBRSxFQUFFaUIsUUFBWCxFQUFtQyxDQUFYLEdBQWUsR0FBZixDQUE0QixDQWhDL0QsQ0FpQ0ksRUFBWSxDQUFQLEVBQUwsRUFBMEIsQ0FqQzlCLENBa0NJLEVBQUVDLEtBQUYsSUFBZ0IsQ0FsQ3BCLENBbUNJLEVBQUVoQixPQUFGLEVBbkNKLEtBc0NNLEVBQUVDLFVBQUYsRUFBZ0IsRUFBYSxDQUFQLEdBQVcsQ0FBakIsQ0F0Q3RCLEVBK0NFLElBTEEsRUFBS1YsUUFBTCxFQUtBLENBQUssRUFBSyxFQUFFd0IsUUFBRixFQUFjLENBQXhCLENBQTJDLENBQUwsR0FBdEMsQ0FBOEMsR0FBOUMsQ0FBcUQsU0FLckQsR0FwREYsQ0FxREUsRUFHRSxHQUFJLEVBQUVqQixJQUFGLENBQU8sQ0FBUCxDQUhOLENBSUUsRUFBRUEsSUFBRixDQUFPLENBQVAsRUFBd0IsRUFBRUEsSUFBRixDQUFPLEVBQUVpQixRQUFGLEVBQVAsQ0FKMUIsQ0FLRSxNQUFvQixDQUFwQixDQUxGLENBUUUsRUFBSSxFQUFFakIsSUFBRixDQUFPLENBQVAsQ0FSTixDQVVFLEVBQUVBLElBQUYsQ0FBTyxFQUFFLEVBQUVDLFFBQVgsR0FWRixDQVdFLEVBQUVELElBQUYsQ0FBTyxFQUFFLEVBQUVDLFFBQVgsR0FYRixDQWNFLEVBQVksQ0FBUCxFQUFMLEVBQTBCLEVBQVMsQ0FBSixFQUFMLEVBQXVCLEVBQVMsQ0FBSixFQUFMLENBZG5ELENBZUUsRUFBRWlCLEtBQUYsSUFBZ0IsQ0FBQyxFQUFFQSxLQUFGLEtBQWMsRUFBRUEsS0FBRixHQUFkLENBQTJCLEVBQUVBLEtBQUYsR0FBM0IsQ0FBd0MsRUFBRUEsS0FBRixHQUF6QyxFQUF1RCxDQWZ6RSxDQWdCRSxFQUFTLENBQUosR0FBUSxDQUFiLEVBQTBCLEVBQVMsQ0FBSixHQUFRLENBQWIsR0FoQjVCLENBbUJFLEVBQUVsQixJQUFGLENBQU8sQ0FBUCxFQUF3QixHQW5CMUIsQ0FvQkUsTUFBb0IsQ0FBcEIsQ0FwQkYsT0FzQnVCLENBQWQsSUFBRWlCLFFBdEJYLEVBd0JBLEVBQUVqQixJQUFGLENBQU8sRUFBRSxFQUFFQyxRQUFYLEVBQXVCLEVBQUVELElBQUYsQ0FBTyxDQUFQLENBN0V6QixDQWtGRSxNQWxGRixDQXFGRSxNQUEwQixFQUFFRCxRQUE1QixDQUNELENBT0QsaUJBSUEsSUFDTSxFQUROLENBR00sQ0FITixDQUVNLEVBQVUsQ0FBQyxDQUZqQixDQUtNLEVBQVUsSUFMaEIsQ0FPTSxFQUFRLENBUGQsQ0FRTSxFQUFZLENBUmxCLENBU00sRUFBWSxDQVRsQixDQWlCRSxJQU5nQixDQUFaLElBTUosR0FMRSxFQUFZLEdBS2QsQ0FKRSxFQUFZLENBSWQsRUFGQSxFQUFzQixDQUFqQixFQUFDLEVBQVcsQ0FBWixFQUFxQixDQUExQixFQUF1QyxLQUV2QyxDQUFLLEVBQUksQ0FBVCxDQUFZLElBQVosQ0FBMkIsR0FBM0IsQ0FBZ0MsQ0FJOUIsR0FIQSxHQUdBLENBRkEsRUFBVSxFQUFlLENBQVYsRUFBQyxFQUFJLENBQUwsRUFBYyxDQUFuQixDQUVWLENBQUksT0FBdUIsS0FBM0IsQ0FDRSxTQURGLElBR1csSUFIWCxDQUlFLEVBQUVZLE9BQUYsQ0FBbUIsQ0FBVCxFQUFWLElBSkYsQ0FNc0IsQ0FBWCxJQU5YLENBV29CLEVBQVQsR0FYWCxDQVlFLEVBQUVBLE9BQUYsQ0FBc0IsQ0FBWixHQUFWLEdBWkYsQ0FlRSxFQUFFQSxPQUFGLENBQXdCLENBQWQsR0FBVixHQWZGLEVBUU0sS0FSTixFQVE0QixFQUFFQSxPQUFGLENBQW1CLENBQVQsRUFBVixHQVI1QixDQVNFLEVBQUVBLE9BQUYsQ0FBb0IsQ0FBVixHQUFWLEdBVEYsRUFrQkEsRUFBUSxDQXRCc0IsQ0F1QjlCLEdBdkI4QixDQXlCZCxDQUFaLElBekIwQixFQTBCNUIsRUFBWSxHQTFCZ0IsQ0EyQjVCLEVBQVksQ0EzQmdCLEVBNkJuQixLQTdCbUIsRUE4QjVCLEVBQVksQ0E5QmdCLENBK0I1QixFQUFZLENBL0JnQixHQWtDNUIsRUFBWSxDQWxDZ0IsQ0FtQzVCLEVBQVksQ0FuQ2dCLENBcUMvQixDQUNGLENBT0QsaUJBSUEsSUFDTSxFQUROLENBR00sQ0FITixDQUVNLEVBQVUsQ0FBQyxDQUZqQixDQUtNLEVBQVUsSUFMaEIsQ0FPTSxFQUFRLENBUGQsQ0FRTSxFQUFZLENBUmxCLENBU00sRUFBWSxDQVRsQixDQWlCRSxJQUxnQixDQUFaLElBS0osR0FKRSxFQUFZLEdBSWQsQ0FIRSxFQUFZLENBR2QsRUFBSyxFQUFJLENBQVQsQ0FBWSxJQUFaLENBQTJCLEdBQTNCLENBQWdDLENBSTlCLEdBSEEsR0FHQSxDQUZBLEVBQVUsRUFBZSxDQUFWLEVBQUMsRUFBSSxDQUFMLEVBQWMsQ0FBbkIsQ0FFVixDQUFJLE9BQXVCLEtBQTNCLENBQ0UsU0FERixJQUdPLElBQUksR0FBSixDQUNMLEVBQUssT0FBcUIsRUFBRUEsT0FBdkIsQ0FBTCxPQUEyRCxDQUFaLEtBQS9DLEVBREssSUFHZSxFQUFYLElBSEosQ0FZYSxFQUFULEdBWkosRUFhTCxPQUF3QixFQUFFQSxPQUExQixDQWJLLENBY0wsSUFBYSxFQUFRLENBQXJCLENBQXdCLENBQXhCLENBZEssR0FpQkwsT0FBMEIsRUFBRUEsT0FBNUIsQ0FqQkssQ0FrQkwsSUFBYSxFQUFRLEVBQXJCLENBQXlCLENBQXpCLENBbEJLLEdBSUQsS0FKQyxHQUtILE1BQXFCLEVBQUVBLE9BQXZCLENBTEcsQ0FNSCxHQU5HLEVBU0wsT0FBc0IsRUFBRUEsT0FBeEIsQ0FUSyxDQVVMLElBQWEsRUFBUSxDQUFyQixDQUF3QixDQUF4QixDQVZLLEVBcUJQLEVBQVEsQ0E1QnNCLENBNkI5QixHQTdCOEIsQ0E4QmQsQ0FBWixJQTlCMEIsRUErQjVCLEVBQVksR0EvQmdCLENBZ0M1QixFQUFZLENBaENnQixFQWtDbkIsS0FsQ21CLEVBbUM1QixFQUFZLENBbkNnQixDQW9DNUIsRUFBWSxDQXBDZ0IsR0F1QzVCLEVBQVksQ0F2Q2dCLENBd0M1QixFQUFZLENBeENnQixDQTBDL0IsQ0FDRixDQU9ELGFBQTBCLENBQ3hCLEdBQUksRUFBSixDQWdCQSxJQWJBLElBQWEsRUFBRUYsU0FBZixDQUEwQixFQUFFWSxNQUFGLENBQVM1QixRQUFuQyxDQWFBLENBWkEsSUFBYSxFQUFFaUIsU0FBZixDQUEwQixFQUFFWSxNQUFGLENBQVM3QixRQUFuQyxDQVlBLENBVEEsSUFBYyxFQUFFOEIsT0FBaEIsQ0FTQSxDQUFLLEVBQWNDLEdBQVcsQ0FBOUIsQ0FBZ0QsQ0FBZixHQUFqQyxFQUMyRCxDQUFyRCxLQUFFYixPQUFGLENBQWtDLENBQXhCLE9BQTRCLENBQXRDLENBRE4sQ0FBbUQsR0FBbkQsRUFVQSxNQUpBLEdBQUVULE9BQUYsRUFBYSxHQUFLLEVBQWMsQ0FBbkIsRUFBd0IsQ0FBeEIsQ0FBNEIsQ0FBNUIsQ0FBZ0MsQ0FJN0MsRUFDRCxDQVFELG1CQUdBLENBQ0UsR0FBSSxFQUFKLENBU0EsSUFIQSxJQUFhLEVBQVMsR0FBdEIsQ0FBMkIsQ0FBM0IsQ0FHQSxDQUZBLElBQWEsRUFBUyxDQUF0QixDQUEyQixDQUEzQixDQUVBLENBREEsSUFBYSxFQUFVLENBQXZCLENBQTJCLENBQTNCLENBQ0EsQ0FBSyxFQUFPLENBQVosQ0FBZSxHQUFmLENBQStCLEdBQS9CLENBRUUsSUFBYSxFQUFFUyxPQUFGLENBQTJCLENBQWpCLE9BQXFCLENBQS9CLENBQWIsQ0FBd0QsQ0FBeEQsRUFJRixJQUFhLEVBQUVGLFNBQWYsQ0FBMEIsRUFBUyxDQUFuQyxDQWhCRixDQW1CRSxJQUFhLEVBQUVDLFNBQWYsQ0FBMEIsRUFBUyxDQUFuQyxDQUVELENBZ0JELGFBQTZCLElBTXZCLEVBTnVCLENBS3ZCLEVBQWEsVUFMVSxDQVMzQixJQUFLLEVBQUksQ0FBVCxDQUFpQixFQUFMLEdBQVosQ0FBcUIsSUFBSyxLQUFnQixDQUExQyxDQUNFLEdBQWtCLENBQWIsRUFBRCxFQUFxRCxDQUFoQyxLQUFFRCxTQUFGLENBQWdCLENBQUosRUFBWixDQUF6QixDQUNFLFNBS0osR0FBb0MsQ0FBaEMsS0FBRUEsU0FBRixNQUFzRSxDQUFqQyxLQUFFQSxTQUFGLElBQXJDLEVBQ2lDLENBQWpDLEtBQUVBLFNBQUYsSUFESixDQUVFLFNBRUYsSUFBSyxFQUFJLEVBQVQsQ0FBYSxJQUFiLENBQTJCLEdBQTNCLENBQ0UsR0FBb0MsQ0FBaEMsS0FBRUEsU0FBRixDQUFnQixDQUFKLEVBQVosQ0FBSixDQUNFLFNBT0osUUFDRCxDQStCRCxtQkFLQSxDQUNFLElBQWEsQ0FBQyxHQUFnQixDQUFqQixHQUF1QixFQUFPLENBQVAsQ0FBVyxDQUFsQyxDQUFiLENBQW1ELENBQW5ELENBREYsQ0FFRSxXQUNELENDaDZCRCxlQUE4QixDQUU1QixNQURBLEdBQUtnQixHQUFMLENBQVdBLEtBQ1gsRUFDRCxDQUVELGFBQWlCLENBQ2YsTUFBTyxDQUFDLEdBQU8sQ0FBUixHQUFvQixDQUFOLEdBQVUsQ0FBVixDQUFjLENBQTVCLENBQ1IsQ0FFRCxhQUFtQixLQUFFLEdBQUksR0FBTSxFQUFJeEMsTUFBaEIsQ0FBd0MsQ0FBVCxLQUEvQixFQUE2QyxLQUFXLENBQU0sQ0FTakYsYUFBNkIsSUFDdkIsR0FBSSxFQUFLeUMsS0FEYyxDQUl2QixFQUFNLEVBQUU5QixPQUplLENBS3ZCLEVBQU0sRUFBSytCLFNBTFksR0FNekIsRUFBTSxFQUFLQSxTQU5jLEVBUWYsQ0FBUixJQVJ1QixHQVUzQmIsRUFBTUMsUUFBTkQsQ0FBZSxFQUFLYyxNQUFwQmQsQ0FBNEIsRUFBRW5CLFdBQTlCbUIsQ0FBMkMsRUFBRWUsV0FBN0NmLEdBQStELEVBQUtnQixRQUFwRWhCLENBVjJCLENBVzNCLEVBQUtnQixRQUFMLEdBWDJCLENBWTNCLEVBQUVELFdBQUYsR0FaMkIsQ0FhM0IsRUFBS0UsU0FBTCxHQWIyQixDQWMzQixFQUFLSixTQUFMLEdBZDJCLENBZTNCLEVBQUUvQixPQUFGLEdBZjJCLENBZ0JULENBQWQsS0FBRUEsT0FoQnFCLEdBaUJ6QixFQUFFaUMsV0FBRixDQUFnQixDQWpCUyxFQW1CNUIsQ0FHRCxlQUFtQyxDQUNqQyxHQUFNRyxlQUFOLEdBQTJDLENBQWpCLElBQUVDLFdBQUYsQ0FBcUIsRUFBRUEsV0FBdkIsQ0FBcUMsQ0FBQyxDQUFoRSxDQUFvRSxFQUFFQyxRQUFGLENBQWEsRUFBRUQsV0FBbkYsR0FEaUMsQ0FFakMsRUFBRUEsV0FBRixDQUFnQixFQUFFQyxRQUZlLENBR2pDLEVBQWMsRUFBRUMsSUFBaEIsQ0FDRCxDQUdELGVBQXdCLENBQ3RCLEVBQUV4QyxXQUFGLENBQWMsRUFBRUMsT0FBRixFQUFkLEdBQ0QsQ0FRRCxlQUEyQixDQUd6QixFQUFFRCxXQUFGLENBQWMsRUFBRUMsT0FBRixFQUFkLEVBQXlDLEdBQVosQ0FBQyxJQUFNLENBSFgsQ0FJekIsRUFBRUQsV0FBRixDQUFjLEVBQUVDLE9BQUYsRUFBZCxFQUFpQyxHQUFKLEVBQzlCLENBVUQsbUJBQTBDLENBQ3hDLEdBQUksR0FBTSxFQUFLd0MsUUFBZixDQUR3QyxPQUdwQyxHQUhvQyxHQUd0QixHQUhzQixFQUk1QixDQUFSLElBSm9DLEVBSWhCLENBSmdCLEVBTXhDLEVBQUtBLFFBQUwsR0FOd0MsQ0FTeEN0QixFQUFNQyxRQUFORCxHQUFvQixFQUFLdUIsS0FBekJ2QixDQUFnQyxFQUFLd0IsT0FBckN4QixLQVR3QyxDQVVoQixDQUFwQixLQUFLWSxLQUFMLENBQVdhLElBVnlCLENBV3RDLEVBQUtDLEtBQUwsQ0FBYUMsR0FBUSxFQUFLRCxLQUFiQyxPQVh5QixDQWNYLENBQXBCLEtBQUtmLEtBQUwsQ0FBV2EsSUFkb0IsR0FldEMsRUFBS0MsS0FBTCxDQUFhRSxHQUFNLEVBQUtGLEtBQVhFLE9BZnlCLEVBa0J4QyxFQUFLSixPQUFMLEdBbEJ3QyxDQW1CeEMsRUFBS0ssUUFBTCxHQW5Cd0MsR0FzQnpDLENBWUQsZUFBcUMsSUFHL0IsRUFIK0IsQ0FJL0IsQ0FKK0IsQ0FDL0IsRUFBZSxFQUFFQyxnQkFEYyxDQUUvQixFQUFPLEVBQUVWLFFBRnNCLENBSy9CLEVBQVcsRUFBRVcsV0FMa0IsQ0FNL0IsRUFBYSxFQUFFQyxVQU5nQixDQU8vQixFQUFTLEVBQUVaLFFBQUYsQ0FBYyxFQUFFYSxNQUFGLEdBQWYsQ0FDUixFQUFFYixRQUFGLEVBQWMsRUFBRWEsTUFBRixHQUFkLENBRFEsQ0FDa0MsQ0FSWCxDQVUvQixFQUFPLEVBQUUvQixNQVZzQixDQVkvQixFQUFRLEVBQUVnQyxNQVpxQixDQWEvQixFQUFRLEVBQUVDLElBYnFCLENBbUIvQixFQUFTLEVBQUVmLFFBQUYsR0FuQnNCLENBb0IvQixFQUFhLEVBQUssSUFBa0IsQ0FBdkIsQ0FwQmtCLENBcUIvQixFQUFhLEVBQUssR0FBTCxDQXJCa0IsQ0E2Qi9CLEVBQUVXLFdBQUYsRUFBaUIsRUFBRUssVUE3QlksR0E4QmpDLElBQWlCLENBOUJnQixFQW1DL0IsRUFBYSxFQUFFQyxTQW5DZ0IsR0FtQ0gsRUFBYSxFQUFFQSxTQW5DWixFQXVDbkMsRUFBRyxDQWFELEdBWEEsR0FXQSxDQUFJLEVBQUssR0FBTCxPQUNBLEVBQUssSUFBbUIsQ0FBeEIsS0FEQSxFQUVBLE9BQStCLElBRi9CLEVBR0EsRUFBSyxHQUFMLElBQStCLEVBQUssRUFBTyxDQUFaLENBSG5DLENBSUUsU0FTRixHQUFRLENBMUJQLENBMkJELEdBM0JDLENBaUNELFNBRVMsRUFBSyxHQUFMLElBQWlCLEVBQUssR0FBTCxDQUFqQixFQUFrQyxFQUFLLEdBQUwsSUFBaUIsRUFBSyxHQUFMLENBQW5ELEVBQ0EsRUFBSyxHQUFMLElBQWlCLEVBQUssR0FBTCxDQURqQixFQUNrQyxFQUFLLEdBQUwsSUFBaUIsRUFBSyxHQUFMLENBRG5ELEVBRUEsRUFBSyxHQUFMLElBQWlCLEVBQUssR0FBTCxDQUZqQixFQUVrQyxFQUFLLEdBQUwsSUFBaUIsRUFBSyxHQUFMLENBRm5ELEVBR0EsRUFBSyxHQUFMLElBQWlCLEVBQUssR0FBTCxDQUhqQixFQUdrQyxFQUFLLEdBQUwsSUFBaUIsRUFBSyxHQUFMLENBSG5ELEVBSUEsR0FOVCxFQWFBLEdBSEEsRUFBTSxJQUFhLEdBQWIsQ0FHTixDQUZBLEVBQU8sSUFFUCxDQUFJLEdBQUosQ0FBb0IsQ0FHbEIsR0FGQSxFQUFFQyxXQUFGLEVBRUEsQ0FEQSxHQUNBLENBQUksSUFBSixDQUNFLE1BRUYsRUFBYSxFQUFLLElBQWtCLENBQXZCLENBTkssQ0FPbEIsRUFBYSxFQUFLLEdBQUwsQ0FDZCxDQUNGLENBdkRELE1BdURTLENBQUMsRUFBWSxFQUFLLEdBQUwsQ0FBYixLQUFvRSxDQUFuQixLQXZEMUQsRUF2Q21DLE1BZ0cvQixJQUFZLEVBQUVELFNBaEdpQixHQW1HNUIsRUFBRUEsU0FDVixDQWFELGFBQXdCLElBRWxCLEVBRmtCLENBRWYsQ0FGZSxDQUVaLENBRlksQ0FFVCxDQUZTLENBRUgsQ0FGRyxDQUNsQixFQUFVLEVBQUVKLE1BRE0sQ0FNdEIsRUFBRyxDQXFCRCxHQXBCQSxFQUFPLEVBQUVNLFdBQUYsQ0FBZ0IsRUFBRUYsU0FBbEIsQ0FBOEIsRUFBRWpCLFFBb0J2QyxDQUFJLEVBQUVBLFFBQUYsRUFBYyxHQUFXLElBQVgsQ0FBbEIsQ0FBdUQsQ0FFckRwQixFQUFNQyxRQUFORCxDQUFlLEVBQUVFLE1BQWpCRixDQUF5QixFQUFFRSxNQUEzQkYsS0FBcUQsQ0FBckRBLENBRnFELENBR3JELEVBQUVzQyxXQUFGLEdBSHFELENBSXJELEVBQUVsQixRQUFGLEdBSnFELENBTXJELEVBQUVELFdBQUYsR0FOcUQsQ0FlckQsRUFBSSxFQUFFcUIsU0FmK0MsQ0FnQnJELEdBaEJxRCxDQWlCckQsRUFDRSxHQUFJLEVBQUVDLElBQUYsQ0FBTyxHQUFQLENBRE4sQ0FFRSxFQUFFQSxJQUFGLElBQWEsS0FBZSxHQUFmLENBQTZCLENBRjVDLE9BR1MsR0FIVCxFQUtBLEdBdEJxRCxDQXVCckQsR0F2QnFELENBd0JyRCxFQUNFLEdBQUksRUFBRU4sSUFBRixDQUFPLEdBQVAsQ0FETixDQUVFLEVBQUVBLElBQUYsSUFBYSxLQUFlLEdBQWYsQ0FBNkIsQ0FGNUMsT0FNUyxHQU5ULEVBUUEsSUFDRCxDQUNELEdBQXdCLENBQXBCLEtBQUVkLElBQUYsQ0FBT0MsUUFBWCxDQUNFLE1BbUJGLEdBSkEsRUFBSSxFQUFTLEVBQUVELElBQVgsQ0FBaUIsRUFBRW5CLE1BQW5CLENBQTJCLEVBQUVrQixRQUFGLENBQWEsRUFBRWlCLFNBQTFDLEdBSUosQ0FIQSxFQUFFQSxTQUFGLEdBR0EsQ0FBSSxFQUFFQSxTQUFGLENBQWMsRUFBRUssTUFBaEIsSUFBSixLQUNFLEVBQU0sRUFBRXRCLFFBQUYsQ0FBYSxFQUFFc0IsTUFEdkIsQ0FFRSxFQUFFQyxLQUFGLENBQVUsRUFBRXpDLE1BQUYsR0FGWixDQUtFLEVBQUV5QyxLQUFGLENBQVUsQ0FBRSxFQUFFQSxLQUFGLEVBQVcsRUFBRUMsVUFBZCxDQUE0QixFQUFFMUMsTUFBRixDQUFTLEVBQU0sQ0FBZixDQUE3QixFQUFrRCxFQUFFMkMsU0FMaEUsQ0FTUyxFQUFFSCxNQVRYLEdBV0ksRUFBRUMsS0FBRixDQUFVLENBQUUsRUFBRUEsS0FBRixFQUFXLEVBQUVDLFVBQWQsQ0FBNEIsRUFBRTFDLE1BQUYsQ0FBUyxLQUFrQixDQUEzQixDQUE3QixFQUE4RCxFQUFFMkMsU0FYOUUsQ0FhSSxFQUFFVixJQUFGLENBQU8sRUFBTSxFQUFFRCxNQUFmLEVBQXlCLEVBQUVPLElBQUYsQ0FBTyxFQUFFRSxLQUFULENBYjdCLENBY0ksRUFBRUYsSUFBRixDQUFPLEVBQUVFLEtBQVQsR0FkSixDQWVJLEdBZkosQ0FnQkksRUFBRUQsTUFBRixFQWhCSixHQWlCUSxFQUFFTCxTQUFGLENBQWMsRUFBRUssTUFBaEIsR0FqQlIsS0EwQkQsQ0FyR0QsTUFxR1MsRUFBRUwsU0FBRixLQUFtRCxDQUFwQixLQUFFaEIsSUFBRixDQUFPQyxRQXJHL0MsQ0EySUQsQ0E2R0QsZUFBZ0MsQ0FJOUIsT0FISSxFQUdKLENBRkksQ0FFSixHQUFTLENBTVAsR0FBSSxFQUFFZSxTQUFGLEdBQUosQ0FBaUMsQ0FFL0IsR0FEQSxJQUNBLENBQUksRUFBRUEsU0FBRixLQUErQixNQUFuQyxDQUNFLFVBRUYsR0FBb0IsQ0FBaEIsS0FBRUEsU0FBTixDQUNFLEtBRUgsQ0F5QkQsR0FwQkEsRUFBWSxDQW9CWixDQW5CSSxFQUFFQSxTQUFGLElBbUJKLEdBakJFLEVBQUVNLEtBQUYsQ0FBVSxDQUFFLEVBQUVBLEtBQUYsRUFBVyxFQUFFQyxVQUFkLENBQTRCLEVBQUUxQyxNQUFGLENBQVMsRUFBRWtCLFFBQUYsSUFBeUIsQ0FBbEMsQ0FBN0IsRUFBcUUsRUFBRXlCLFNBaUJuRixDQWhCRSxFQUFZLEVBQUVWLElBQUYsQ0FBTyxFQUFFZixRQUFGLENBQWEsRUFBRWMsTUFBdEIsRUFBZ0MsRUFBRU8sSUFBRixDQUFPLEVBQUVFLEtBQVQsQ0FnQjlDLENBZkUsRUFBRUYsSUFBRixDQUFPLEVBQUVFLEtBQVQsRUFBa0IsRUFBRXZCLFFBZXRCLEVBUmtCLENBQWQsTUFBNEIsRUFBRUEsUUFBRixFQUFELEVBQTZCLEVBQUVhLE1BQUYsR0FRNUQsR0FIRSxFQUFFYSxZQUFGLENBQWlCLE1BR25CLElBQUksRUFBRUEsWUFBRixJQUFKLEVBNkNFLEVBQVMsR0FBTUMsU0FBTixHQUFtQixDQUFuQixDQUFzQixFQUFFN0MsTUFBRixDQUFTLEVBQUVrQixRQUFYLENBQXRCLENBN0NYLENBK0NFLEVBQUVpQixTQUFGLEVBL0NGLENBZ0RFLEVBQUVqQixRQUFGLEVBaERGLEtBWUUsSUFQQSxFQUFTLEdBQU0yQixTQUFOLEdBQW1CLEVBQUUzQixRQUFGLENBQWEsRUFBRWtCLFdBQWxDLENBQStDLEVBQUVRLFlBQUYsR0FBL0MsQ0FPVCxDQUxBLEVBQUVULFNBQUYsRUFBZSxFQUFFUyxZQUtqQixDQUFJLEVBQUVBLFlBQUYsRUFBa0IsRUFBRUUsY0FBcEIsRUFBMkQsRUFBRVgsU0FBRixJQUEvRCxDQUF5RixDQUN2RixFQUFFUyxZQUFGLEVBRHVGLENBRXZGLEVBQ0UsR0FBRTFCLFFBQUYsRUFERixDQUdFLEVBQUV1QixLQUFGLENBQVUsQ0FBRSxFQUFFQSxLQUFGLEVBQVcsRUFBRUMsVUFBZCxDQUE0QixFQUFFMUMsTUFBRixDQUFTLEVBQUVrQixRQUFGLElBQXlCLENBQWxDLENBQTdCLEVBQXFFLEVBQUV5QixTQUhuRixDQUlFLEVBQVksRUFBRVYsSUFBRixDQUFPLEVBQUVmLFFBQUYsQ0FBYSxFQUFFYyxNQUF0QixFQUFnQyxFQUFFTyxJQUFGLENBQU8sRUFBRUUsS0FBVCxDQUo5QyxDQUtFLEVBQUVGLElBQUYsQ0FBTyxFQUFFRSxLQUFULEVBQWtCLEVBQUV2QixRQUx0QixPQVU4QixDQUFyQixJQUFFLEVBQUUwQixZQVZiLEVBV0EsRUFBRTFCLFFBQUYsRUFDRCxDQWRELElBZ0JFLEdBQUVBLFFBQUYsRUFBYyxFQUFFMEIsWUFoQmxCLENBaUJFLEVBQUVBLFlBQUYsQ0FBaUIsQ0FqQm5CLENBa0JFLEVBQUVILEtBQUYsQ0FBVSxFQUFFekMsTUFBRixDQUFTLEVBQUVrQixRQUFYLENBbEJaLENBb0JFLEVBQUV1QixLQUFGLENBQVUsQ0FBRSxFQUFFQSxLQUFGLEVBQVcsRUFBRUMsVUFBZCxDQUE0QixFQUFFMUMsTUFBRixDQUFTLEVBQUVrQixRQUFGLENBQWEsQ0FBdEIsQ0FBN0IsRUFBeUQsRUFBRXlCLFNBcEJ2RSxDQXNDRixPQUVFLE9BRkYsQ0FHMkIsQ0FBckIsS0FBRXhCLElBQUYsQ0FBT1IsU0FIYixFQUlJLFNBSUwsQ0FyRzZCLE1Bc0c5QixHQUFFNkIsTUFBRixDQUFhLEVBQUV0QixRQUFGLENBQWMsR0FBWSxDQUEzQixDQUFpQyxFQUFFQSxRQUFuQyxDQUE4QyxHQUFZLENBdEd4QyxDQXVHMUIsTUF2RzBCLEVBeUc1QixPQXpHNEIsQ0EwR0gsQ0FBckIsS0FBRUMsSUFBRixDQUFPUixTQTFHaUIsUUFnSDFCLEVBQUVmLFFBaEh3QixHQWtINUIsT0FsSDRCLENBbUhILENBQXJCLEtBQUV1QixJQUFGLENBQU9SLFNBbkhpQixPQXlIL0IsQ0FPRCxlQUFnQyxDQU85QixPQU5JLEVBTUosQ0FMSSxDQUtKLENBSEksQ0FHSixHQUFTLENBTVAsR0FBSSxFQUFFd0IsU0FBRixHQUFKLENBQWlDLENBRS9CLEdBREEsSUFDQSxDQUFJLEVBQUVBLFNBQUYsS0FBK0IsTUFBbkMsQ0FDRSxVQUVGLEdBQW9CLENBQWhCLEtBQUVBLFNBQU4sQ0FBeUIsS0FDMUIsQ0F5Q0QsR0FwQ0EsRUFBWSxDQW9DWixDQW5DSSxFQUFFQSxTQUFGLElBbUNKLEdBakNFLEVBQUVNLEtBQUYsQ0FBVSxDQUFFLEVBQUVBLEtBQUYsRUFBVyxFQUFFQyxVQUFkLENBQTRCLEVBQUUxQyxNQUFGLENBQVMsRUFBRWtCLFFBQUYsSUFBeUIsQ0FBbEMsQ0FBN0IsRUFBcUUsRUFBRXlCLFNBaUNuRixDQWhDRSxFQUFZLEVBQUVWLElBQUYsQ0FBTyxFQUFFZixRQUFGLENBQWEsRUFBRWMsTUFBdEIsRUFBZ0MsRUFBRU8sSUFBRixDQUFPLEVBQUVFLEtBQVQsQ0FnQzlDLENBL0JFLEVBQUVGLElBQUYsQ0FBTyxFQUFFRSxLQUFULEVBQWtCLEVBQUV2QixRQStCdEIsRUF6QkEsRUFBRVcsV0FBRixDQUFnQixFQUFFZSxZQXlCbEIsQ0F4QkEsRUFBRUcsVUFBRixDQUFlLEVBQUVYLFdBd0JqQixDQXZCQSxFQUFFUSxZQUFGLENBQWlCLEdBQVksQ0F1QjdCLENBckJrQixDQUFkLE1BQTBCLEVBQUVmLFdBQUYsQ0FBZ0IsRUFBRWlCLGNBQTVDLEVBQ0EsRUFBRTVCLFFBQUYsSUFBMkIsRUFBRWEsTUFBRixHQW9CL0IsR0FmRSxFQUFFYSxZQUFGLENBQWlCLE1BZW5CLENBWndCLENBQWxCLElBQUVBLFlBQUYsR0FDQSxFQUFFSSxRQUFGLE9BQThCLEVBQUVKLFlBQUYsT0FBNkQsSUFBN0IsR0FBRTFCLFFBQUYsQ0FBYSxFQUFFa0IsV0FEN0UsQ0FZTixHQU5JLEVBQUVRLFlBQUYsQ0FBaUIsR0FBWSxDQU1qQyxHQUFJLEVBQUVmLFdBQUYsTUFBOEIsRUFBRWUsWUFBRixFQUFrQixFQUFFZixXQUF0RCxDQUFtRSxDQUNqRSxFQUFhLEVBQUVYLFFBQUYsQ0FBYSxFQUFFaUIsU0FBZixHQURvRCxDQVFqRSxFQUFTLEdBQU1VLFNBQU4sR0FBbUIsRUFBRTNCLFFBQUYsQ0FBYSxDQUFiLENBQWlCLEVBQUU2QixVQUF0QyxDQUFrRCxFQUFFbEIsV0FBRixHQUFsRCxDQVJ3RCxDQWNqRSxFQUFFTSxTQUFGLEVBQWUsRUFBRU4sV0FBRixDQUFnQixDQWRrQyxDQWVqRSxFQUFFQSxXQUFGLEVBQWlCLENBZmdELENBZ0JqRSxFQUNNLEVBQUUsRUFBRVgsUUFBSixHQUROLEdBR0ksRUFBRXVCLEtBQUYsQ0FBVSxDQUFFLEVBQUVBLEtBQUYsRUFBVyxFQUFFQyxVQUFkLENBQTRCLEVBQUUxQyxNQUFGLENBQVMsRUFBRWtCLFFBQUYsSUFBeUIsQ0FBbEMsQ0FBN0IsRUFBcUUsRUFBRXlCLFNBSHJGLENBSUksRUFBWSxFQUFFVixJQUFGLENBQU8sRUFBRWYsUUFBRixDQUFhLEVBQUVjLE1BQXRCLEVBQWdDLEVBQUVPLElBQUYsQ0FBTyxFQUFFRSxLQUFULENBSmhELENBS0ksRUFBRUYsSUFBRixDQUFPLEVBQUVFLEtBQVQsRUFBa0IsRUFBRXZCLFFBTHhCLFFBUTZCLENBQXBCLElBQUUsRUFBRVcsV0FSYixFQWFBLEdBSkEsRUFBRW9CLGVBQUYsQ0FBb0IsQ0FJcEIsQ0FIQSxFQUFFTCxZQUFGLENBQWlCLEdBQVksQ0FHN0IsQ0FGQSxFQUFFMUIsUUFBRixFQUVBLEtBRUUsT0FGRixDQUcyQixDQUFyQixLQUFFQyxJQUFGLENBQU9SLFNBSGIsRUFJSSxTQUtMLENBdENELElBc0NPLEtBQUksRUFBRXNDLGVBQU4sQ0F1QkwsRUFBRUEsZUFBRixDQUFvQixDQXZCZixDQXdCTCxFQUFFL0IsUUFBRixFQXhCSyxDQXlCTCxFQUFFaUIsU0FBRixFQXpCSyxLQWdCTCxJQVRBLEVBQVMsR0FBTVUsU0FBTixHQUFtQixDQUFuQixDQUFzQixFQUFFN0MsTUFBRixDQUFTLEVBQUVrQixRQUFGLENBQWEsQ0FBdEIsQ0FBdEIsQ0FTVCxJQUxFLE9BS0YsQ0FGQSxFQUFFQSxRQUFGLEVBRUEsQ0FEQSxFQUFFaUIsU0FBRixFQUNBLENBQXlCLENBQXJCLEtBQUVoQixJQUFGLENBQU9SLFNBQVgsQ0FDRSxTQVVMLENBN0g2QixNQStIMUIsR0FBRXNDLGVBL0h3QixHQWtJNUIsRUFBUyxHQUFNSixTQUFOLEdBQW1CLENBQW5CLENBQXNCLEVBQUU3QyxNQUFGLENBQVMsRUFBRWtCLFFBQUYsQ0FBYSxDQUF0QixDQUF0QixDQWxJbUIsQ0FvSTVCLEVBQUUrQixlQUFGLENBQW9CLENBcElRLEVBc0k5QixFQUFFVCxNQUFGLENBQVcsRUFBRXRCLFFBQUYsQ0FBYSxHQUFZLENBQXpCLENBQTZCLEVBQUVBLFFBQS9CLENBQTBDLEdBQVksQ0F0SW5DLENBdUkxQixNQXZJMEIsRUF5STVCLE9Bekk0QixDQTBJSCxDQUFyQixLQUFFQyxJQUFGLENBQU9SLFNBMUlpQixRQWdKMUIsRUFBRWYsUUFoSndCLEdBa0o1QixPQWxKNEIsQ0FtSkgsQ0FBckIsS0FBRXVCLElBQUYsQ0FBT1IsU0FuSmlCLE9BMEovQixDQVFELGVBQStCLENBTzdCLE9BTkksRUFNSixDQUxJLENBS0osQ0FKSSxDQUlKLENBSlUsQ0FJVixDQUZJLEVBQU8sRUFBRVgsTUFFYixHQUFTLENBS1AsR0FBSSxFQUFFbUMsU0FBRixJQUFKLENBQThCLENBRTVCLEdBREEsSUFDQSxDQUFJLEVBQUVBLFNBQUYsTUFBNEIsTUFBaEMsQ0FDRSxVQUVGLEdBQW9CLENBQWhCLEtBQUVBLFNBQU4sQ0FBeUIsS0FDMUIsQ0FJRCxHQURBLEVBQUVTLFlBQUYsQ0FBaUIsQ0FDakIsQ0FBSSxFQUFFVCxTQUFGLE1BQXlDLENBQWIsR0FBRWpCLFFBQWxDLEdBQ0UsRUFBTyxFQUFFQSxRQUFGLENBQWEsQ0FEdEIsQ0FFRSxFQUFPLElBRlQsQ0FHTSxJQUFTLEVBQUssR0FBTCxDQUFULEVBQXlCLElBQVMsRUFBSyxHQUFMLENBQWxDLEVBQWtELElBQVMsRUFBSyxHQUFMLENBSGpFLEVBRytFLENBQzNFLEVBQVMsRUFBRUEsUUFBRixHQURrRSxDQUUzRSxTQUVTLElBQVMsRUFBSyxHQUFMLENBQVQsRUFBeUIsSUFBUyxFQUFLLEdBQUwsQ0FBbEMsRUFDQSxJQUFTLEVBQUssR0FBTCxDQURULEVBQ3lCLElBQVMsRUFBSyxHQUFMLENBRGxDLEVBRUEsSUFBUyxFQUFLLEdBQUwsQ0FGVCxFQUV5QixJQUFTLEVBQUssR0FBTCxDQUZsQyxFQUdBLElBQVMsRUFBSyxHQUFMLENBSFQsRUFHeUIsSUFBUyxFQUFLLEdBQUwsQ0FIbEMsRUFJQSxHQU5ULEVBT0EsRUFBRTBCLFlBQUYsQ0FBaUIsSUFBYSxHQUFiLENBVDBELENBVXZFLEVBQUVBLFlBQUYsQ0FBaUIsRUFBRVQsU0FWb0QsR0FXekUsRUFBRVMsWUFBRixDQUFpQixFQUFFVCxTQVhzRCxDQWE1RSxDQXVCSCxHQWxCSSxFQUFFUyxZQUFGLElBa0JKLEVBZEUsRUFBUyxHQUFNQyxTQUFOLEdBQW1CLENBQW5CLENBQXNCLEVBQUVELFlBQUYsR0FBdEIsQ0FjWCxDQVpFLEVBQUVULFNBQUYsRUFBZSxFQUFFUyxZQVluQixDQVhFLEVBQUUxQixRQUFGLEVBQWMsRUFBRTBCLFlBV2xCLENBVkUsRUFBRUEsWUFBRixDQUFpQixDQVVuQixHQUxFLEVBQVMsR0FBTUMsU0FBTixHQUFtQixDQUFuQixDQUFzQixFQUFFN0MsTUFBRixDQUFTLEVBQUVrQixRQUFYLENBQXRCLENBS1gsQ0FIRSxFQUFFaUIsU0FBRixFQUdGLENBRkUsRUFBRWpCLFFBQUYsRUFFRixNQUVFLE9BRkYsQ0FHMkIsQ0FBckIsS0FBRUMsSUFBRixDQUFPUixTQUhiLEVBSUksU0FJTCxDQXJFNEIsTUFzRTdCLEdBQUU2QixNQUFGLENBQVcsQ0F0RWtCLENBdUV6QixNQXZFeUIsRUF5RTNCLE9BekUyQixDQTBFRixDQUFyQixLQUFFckIsSUFBRixDQUFPUixTQTFFZ0IsUUFnRnpCLEVBQUVmLFFBaEZ1QixHQWtGM0IsT0FsRjJCLENBbUZGLENBQXJCLEtBQUV1QixJQUFGLENBQU9SLFNBbkZnQixPQXlGOUIsQ0FNRCxlQUFnQyxDQUc5QixJQUZBLEdBQUksRUFFSixHQUFTLENBRVAsR0FBb0IsQ0FBaEIsS0FBRXdCLFNBQU4sR0FDRSxJQURGLENBRXNCLENBQWhCLEtBQUVBLFNBRlIsRUFFeUIsQ0FDckIsR0FBSSxNQUFKLENBQ0UsVUFFRixLQUNELENBVUgsR0FOQSxFQUFFUyxZQUFGLENBQWlCLENBTWpCLENBSEEsRUFBUyxHQUFNQyxTQUFOLEdBQW1CLENBQW5CLENBQXNCLEVBQUU3QyxNQUFGLENBQVMsRUFBRWtCLFFBQVgsQ0FBdEIsQ0FHVCxDQUZBLEVBQUVpQixTQUFGLEVBRUEsQ0FEQSxFQUFFakIsUUFBRixFQUNBLEtBRUUsT0FGRixDQUcyQixDQUFyQixLQUFFQyxJQUFGLENBQU9SLFNBSGIsRUFJSSxTQUlMLENBOUI2QixNQStCOUIsR0FBRTZCLE1BQUYsQ0FBVyxDQS9CbUIsQ0FnQzFCLE1BaEMwQixFQWtDNUIsT0FsQzRCLENBbUNILENBQXJCLEtBQUVyQixJQUFGLENBQU9SLFNBbkNpQixRQXlDMUIsRUFBRWYsUUF6Q3dCLEdBMkM1QixPQTNDNEIsQ0E0Q0gsQ0FBckIsS0FBRXVCLElBQUYsQ0FBT1IsU0E1Q2lCLE9Ba0QvQixDQU9ELHFCQUFxRSxDQUNuRSxLQUFLdUMsV0FBTCxFQURtRSxDQUVuRSxLQUFLQyxRQUFMLEVBRm1FLENBR25FLEtBQUtDLFdBQUwsRUFIbUUsQ0FJbkUsS0FBS0MsU0FBTCxFQUptRSxDQUtuRSxLQUFLQyxJQUFMLEVBQ0QsQ0F1QkQsYUFBb0IsQ0FDbEIsRUFBRWpCLFdBQUYsQ0FBZ0IsRUFBSSxFQUFFTixNQURKLENBSWxCLEVBQUssRUFBRVEsSUFBUCxDQUprQixDQVFsQixFQUFFTyxjQUFGLENBQW1CLEdBQW9CLEVBQUVTLEtBQXRCLEVBQTZCSixRQVI5QixDQVNsQixFQUFFakIsVUFBRixDQUFlLEdBQW9CLEVBQUVxQixLQUF0QixFQUE2QkwsV0FUMUIsQ0FVbEIsRUFBRXBCLFVBQUYsQ0FBZSxHQUFvQixFQUFFeUIsS0FBdEIsRUFBNkJILFdBVjFCLENBV2xCLEVBQUV4QixnQkFBRixDQUFxQixHQUFvQixFQUFFMkIsS0FBdEIsRUFBNkJGLFNBWGhDLENBYWxCLEVBQUVuQyxRQUFGLENBQWEsQ0FiSyxDQWNsQixFQUFFRCxXQUFGLENBQWdCLENBZEUsQ0FlbEIsRUFBRWtCLFNBQUYsQ0FBYyxDQWZJLENBZ0JsQixFQUFFSyxNQUFGLENBQVcsQ0FoQk8sQ0FpQmxCLEVBQUVJLFlBQUYsQ0FBaUIsRUFBRWYsV0FBRixDQUFnQixHQUFZLENBakIzQixDQWtCbEIsRUFBRW9CLGVBQUYsQ0FBb0IsQ0FsQkYsQ0FtQmxCLEVBQUVSLEtBQUYsQ0FBVSxDQUNYLENBR0QsWUFBd0IsQ0FDdEIsS0FBS3RCLElBQUwsQ0FBWSxJQURVLENBRXRCLEtBQUtxQyxNQUFMLENBQWMsQ0FGUSxDQUd0QixLQUFLN0UsV0FBTCxDQUFtQixJQUhHLENBSXRCLEtBQUs4RSxnQkFBTCxDQUF3QixDQUpGLENBS3RCLEtBQUs1QyxXQUFMLENBQW1CLENBTEcsQ0FNdEIsS0FBS2pDLE9BQUwsQ0FBZSxDQU5PLENBT3RCLEtBQUsyQyxJQUFMLENBQVksQ0FQVSxDQVF0QixLQUFLbUMsTUFBTCxDQUFjLElBUlEsQ0FTdEIsS0FBS0MsT0FBTCxDQUFlLENBVE8sQ0FVdEIsS0FBS0MsTUFBTCxHQVZzQixDQVd0QixLQUFLQyxVQUFMLENBQWtCLENBQUMsQ0FYRyxDQWF0QixLQUFLOUIsTUFBTCxDQUFjLENBYlEsQ0FjdEIsS0FBSytCLE1BQUwsQ0FBYyxDQWRRLENBZXRCLEtBQUs5QixNQUFMLENBQWMsQ0FmUSxDQWlCdEIsS0FBS2hDLE1BQUwsQ0FBYyxJQWpCUSxDQXlCdEIsS0FBS3FDLFdBQUwsQ0FBbUIsQ0F6QkcsQ0E4QnRCLEtBQUtKLElBQUwsQ0FBWSxJQTlCVSxDQW9DdEIsS0FBS00sSUFBTCxDQUFZLElBcENVLENBc0N0QixLQUFLRSxLQUFMLENBQWEsQ0F0Q1MsQ0F1Q3RCLEtBQUtILFNBQUwsQ0FBaUIsQ0F2Q0ssQ0F3Q3RCLEtBQUt5QixTQUFMLENBQWlCLENBeENLLENBeUN0QixLQUFLcEIsU0FBTCxDQUFpQixDQXpDSyxDQTJDdEIsS0FBS0QsVUFBTCxDQUFrQixDQTNDSSxDQWtEdEIsS0FBS3pCLFdBQUwsQ0FBbUIsQ0FsREcsQ0F1RHRCLEtBQUsyQixZQUFMLENBQW9CLENBdkRFLENBd0R0QixLQUFLRyxVQUFMLENBQWtCLENBeERJLENBeUR0QixLQUFLRSxlQUFMLENBQXVCLENBekRELENBMER0QixLQUFLL0IsUUFBTCxDQUFnQixDQTFETSxDQTJEdEIsS0FBS2tCLFdBQUwsQ0FBbUIsQ0EzREcsQ0E0RHRCLEtBQUtELFNBQUwsQ0FBaUIsQ0E1REssQ0E4RHRCLEtBQUtOLFdBQUwsQ0FBbUIsQ0E5REcsQ0FtRXRCLEtBQUtELGdCQUFMLENBQXdCLENBbkVGLENBeUV0QixLQUFLa0IsY0FBTCxDQUFzQixDQXpFQSxDQXFGdEIsS0FBS1MsS0FBTCxDQUFhLENBckZTLENBc0Z0QixLQUFLUCxRQUFMLENBQWdCLENBdEZNLENBd0Z0QixLQUFLZCxVQUFMLENBQWtCLENBeEZJLENBMkZ0QixLQUFLSixVQUFMLENBQWtCLENBM0ZJLENBdUd0QixLQUFLckMsU0FBTCxDQUFrQixHQUFJSyxHQUFNa0UsS0FBVixDQUE0QixDQUFaLEdBQWhCLENBdkdJLENBd0d0QixLQUFLdEUsU0FBTCxDQUFrQixHQUFJSSxHQUFNa0UsS0FBVixDQUFvQyxDQUFwQixFQUFDLEtBQWMsQ0FBZixDQUFoQixDQXhHSSxDQXlHdEIsS0FBS3JFLE9BQUwsQ0FBa0IsR0FBSUcsR0FBTWtFLEtBQVYsQ0FBcUMsQ0FBckIsRUFBQyxLQUFlLENBQWhCLENBQWhCLENBekdJLENBMEd0QixFQUFLLEtBQUt2RSxTQUFWLENBMUdzQixDQTJHdEIsRUFBSyxLQUFLQyxTQUFWLENBM0dzQixDQTRHdEIsRUFBSyxLQUFLQyxPQUFWLENBNUdzQixDQThHdEIsS0FBS1UsTUFBTCxDQUFnQixJQTlHTSxDQStHdEIsS0FBS0MsTUFBTCxDQUFnQixJQS9HTSxDQWdIdEIsS0FBS0MsT0FBTCxDQUFnQixJQWhITSxDQW1IdEIsS0FBS3hCLFFBQUwsQ0FBZ0IsR0FBSWUsR0FBTWtFLEtBQVYsQ0FBZ0IsR0FBVyxDQUEzQixDQW5ITSxDQXVIdEIsS0FBS2hGLElBQUwsQ0FBWSxHQUFJYyxHQUFNa0UsS0FBVixDQUFnQixLQUFjLENBQTlCLENBdkhVLENBd0h0QixFQUFLLEtBQUtoRixJQUFWLENBeEhzQixDQTBIdEIsS0FBS2lCLFFBQUwsQ0FBZ0IsQ0ExSE0sQ0EySHRCLEtBQUtoQixRQUFMLENBQWdCLENBM0hNLENBZ0l0QixLQUFLaUIsS0FBTCxDQUFhLEdBQUlKLEdBQU1rRSxLQUFWLENBQWdCLEtBQWMsQ0FBOUIsQ0FoSVMsQ0FpSXRCLEVBQUssS0FBSzlELEtBQVYsQ0FqSXNCLENBcUl0QixLQUFLRSxLQUFMLENBQWEsQ0FySVMsQ0F1SXRCLEtBQUs2RCxXQUFMLENBQW1CLENBdklHLENBMkp0QixLQUFLckUsUUFBTCxDQUFnQixDQTNKTSxDQTZKdEIsS0FBS08sS0FBTCxDQUFhLENBN0pTLENBbUt0QixLQUFLakIsT0FBTCxDQUFlLENBbktPLENBb0t0QixLQUFLQyxVQUFMLENBQWtCLENBcEtJLENBcUt0QixLQUFLVSxPQUFMLENBQWUsQ0FyS08sQ0FzS3RCLEtBQUsyQyxNQUFMLENBQWMsQ0F0S1EsQ0F5S3RCLEtBQUsxRCxNQUFMLENBQWMsQ0F6S1EsQ0E2S3RCLEtBQUtELFFBQUwsQ0FBZ0IsQ0FhakIsQ0FHRCxhQUFnQyxDQUM5QixHQUFJLEVBQUosQ0FEOEIsTUFHMUIsSUFBVSxFQUFLNkIsS0FIVyxFQU85QixFQUFLaUIsUUFBTCxDQUFnQixFQUFLWixTQUFMLENBQWlCLENBUEgsQ0FROUIsRUFBS21ELFNBQUwsR0FSOEIsQ0FVOUIsRUFBSSxFQUFLeEQsS0FWcUIsQ0FXOUIsRUFBRTlCLE9BQUYsQ0FBWSxDQVhrQixDQVk5QixFQUFFaUMsV0FBRixDQUFnQixDQVpjLENBY2pCLENBQVQsR0FBRVUsSUFkd0IsR0FlNUIsRUFBRUEsSUFBRixDQUFTLENBQUMsRUFBRUEsSUFmZ0IsRUFrQjlCLEVBQUVpQyxNQUFGLENBQVksRUFBRWpDLElBQUYsTUFsQmtCLENBbUI5QixFQUFLQyxLQUFMLENBQXlCLENBQVgsS0FBRUQsSUFBSCxDQUNYLENBRFcsQ0FHWCxDQXRCNEIsQ0F1QjlCLEVBQUVzQyxVQUFGLEdBdkI4QixDQXdCOUIsR0FBTU0sUUFBTixHQXhCOEIsS0FJckIsT0FzQlYsQ0FHRCxhQUE0QixDQUMxQixHQUFJLEdBQU0sSUFBVixDQUlBLE1BSEksT0FHSixFQUZFLEVBQVEsRUFBS3pELEtBQWIsQ0FFRixFQUNELENBV0QsdUJBQTJFLENBQ3pFLEdBQUksRUFBSixDQUNFLFVBRUYsR0FBSSxHQUFPLENBQVgsQ0FpQkEsR0FmSSxNQWVKLEdBZEUsRUFBUSxDQWNWLEVBWGlCLENBQWIsRUFXSixFQVZFLEVBQU8sQ0FVVCxDQVRFLEVBQWEsRUFTZixFQU5zQixFQUFiLEVBTVQsR0FMRSxFQUFPLENBS1QsQ0FKRSxHQUFjLEVBSWhCLEVBQWUsQ0FBWCxJQUFnQixJQUFoQixFQUE0QyxNQUE1QyxFQUNXLENBQWIsRUFERSxFQUM2QixFQUFiLEVBRGhCLEVBQzJDLENBQVIsRUFEbkMsRUFDd0QsQ0FBUixFQURoRCxFQUVTLENBQVgsRUFGRSxFQUVjLElBRmxCLENBR0UsTUFBTyxRQUFQLENBSWlCLENBQWYsSUE1QnFFLEdBNkJ2RSxFQUFhLENBN0IwRCxFQWlDekUsR0FBSSxHQUFJLEtBQVIsQ0EwQ0EsTUF4Q0EsR0FBS0EsS0FBTCxFQXdDQSxDQXZDQSxFQUFFUyxJQUFGLEVBdUNBLENBckNBLEVBQUVJLElBQUYsRUFxQ0EsQ0FwQ0EsRUFBRW1DLE1BQUYsQ0FBVyxJQW9DWCxDQW5DQSxFQUFFSSxNQUFGLEVBbUNBLENBbENBLEVBQUUvQixNQUFGLENBQVcsR0FBSyxFQUFFK0IsTUFrQ2xCLENBakNBLEVBQUU5QixNQUFGLENBQVcsRUFBRUQsTUFBRixDQUFXLENBaUN0QixDQS9CQSxFQUFFZ0MsU0FBRixDQUFjLEVBQVcsQ0ErQnpCLENBOUJBLEVBQUV6QixTQUFGLENBQWMsR0FBSyxFQUFFeUIsU0E4QnJCLENBN0JBLEVBQUVwQixTQUFGLENBQWMsRUFBRUwsU0FBRixDQUFjLENBNkI1QixDQTVCQSxFQUFFSSxVQUFGLENBQWUsQ0FBQyxFQUFFLENBQUMsRUFBRXFCLFNBQUYsSUFBMEIsQ0FBM0IsSUFBRixDQTRCaEIsQ0ExQkEsRUFBRS9ELE1BQUYsQ0FBVyxHQUFJRixHQUFNc0UsSUFBVixDQUEwQixDQUFYLEdBQUVyQyxNQUFqQixDQTBCWCxDQXpCQSxFQUFFUSxJQUFGLENBQVMsR0FBSXpDLEdBQU1rRSxLQUFWLENBQWdCLEVBQUUxQixTQUFsQixDQXlCVCxDQXhCQSxFQUFFTCxJQUFGLENBQVMsR0FBSW5DLEdBQU1rRSxLQUFWLENBQWdCLEVBQUVqQyxNQUFsQixDQXdCVCxDQW5CQSxFQUFFa0MsV0FBRixDQUFnQixHQUFNLEVBQVcsQ0FtQmpDLENBakJBLEVBQUVSLGdCQUFGLENBQXFDLENBQWhCLEdBQUVRLFdBaUJ2QixDQWJBLEVBQUV0RixXQUFGLENBQWdCLEdBQUltQixHQUFNc0UsSUFBVixDQUFlLEVBQUVYLGdCQUFqQixDQWFoQixDQVRBLEVBQUV0RCxLQUFGLENBQVUsRUFBSSxFQUFFOEQsV0FTaEIsQ0FOQSxFQUFFN0QsS0FBRixDQUFVLEVBQVUsRUFBRTZELFdBTXRCLENBSkEsRUFBRVYsS0FBRixFQUlBLENBSEEsRUFBRVAsUUFBRixFQUdBLENBRkEsRUFBRVksTUFBRixFQUVBLENBQU8sSUFDUixDQ3R5Q0QsZUFBaUMsQ0FFL0IsR0FBVSxLQUFOLEVBQUosR0FDTyxFQUFJUyxRQUFKLElBQUQsRUFBdUMsQ0FBQyxFQUFJQSxRQUFMLElBRDdDLEVBRUksTUFBTyxHQUFvQkMsS0FBcEIsQ0FBMEIsSUFBMUIsQ0FBZ0N4RSxFQUFNeUUsU0FBTnpFLEtBQWhDLENBQVAsQ0FLSixPQURJLEdBQVMsRUFDYixDQUFTLEVBQUksQ0FBYixDQUFnQixHQUFoQixDQUF5QixHQUF6QixDQUNFLEdBQVUsRUFBb0IsSUFBcEIsQ0FBVixDQUVGLFFBQ0QsQ0NzQkQsYUFBMEIsQ0FDeEIsR0FBSSxFQUFFLGlCQUFGLENBQUosQ0FBZ0MsTUFBTyxTQUFQLENBRWhDLEtBQUswRSxPQUFMLENBQWUxRSxFQUFNMkUsTUFBTjNFLENBQWEsQ0FDMUJ5RCxRQUQwQixDQUUxQkssU0FGMEIsQ0FHMUJjLFVBQVcsS0FIZSxDQUkxQkMsV0FBWSxFQUpjLENBSzFCQyxTQUFVLENBTGdCLENBTTFCNUIsV0FOMEIsQ0FPMUI2QixHQUFJLEVBUHNCLENBQWIvRSxDQVFaLEtBUllBLENBSFMsQ0FheEIsR0FBSSxHQUFNLEtBQUswRSxPQUFmLENBRUksRUFBSU0sR0FBSixFQUE2QixDQUFqQixHQUFJSCxVQWZJLENBZ0J0QixFQUFJQSxVQUFKLENBQWlCLENBQUMsRUFBSUEsVUFoQkEsQ0FtQmYsRUFBSUksSUFBSixFQUE4QixDQUFqQixHQUFJSixVQUFqQixFQUFzRCxFQUFqQixHQUFJQSxVQW5CMUIsR0FvQnRCLEVBQUlBLFVBQUosRUFBa0IsRUFwQkksRUF1QnhCLEtBQUtLLEdBQUwsQ0FBYyxDQXZCVSxDQXdCeEIsS0FBS3ZFLEdBQUwsQ0FBYyxFQXhCVSxDQXlCeEIsS0FBS3dFLEtBQUwsR0F6QndCLENBMEJ4QixLQUFLQyxNQUFMLEdBMUJ3QixDQTRCeEIsS0FBSy9ELElBQUwsQ0FBWSxNQTVCWSxDQTZCeEIsS0FBS0EsSUFBTCxDQUFVUixTQUFWLENBQXNCLENBN0JFLENBK0J4QixHQUFJLEdBQVN3RSxHQUFhQyxZQUFiRCxDQUNYLEtBQUtoRSxJQURNZ0UsQ0FFWCxFQUFJNUIsS0FGTzRCLENBR1gsRUFBSXZCLE1BSE91QixDQUlYLEVBQUlSLFVBSk9RLENBS1gsRUFBSVAsUUFMT08sQ0FNWCxFQUFJbkMsUUFOT21DLENBQWIsQ0FTQSxHQUFJLE1BQUosQ0FDRSxLQUFNLElBQUlFLE1BQUosQ0FBVTVFLEtBQVYsQ0FBTixDQU9GLEdBSkksRUFBSTZFLE1BSVIsRUFIRUgsR0FBYUksZ0JBQWJKLENBQThCLEtBQUtoRSxJQUFuQ2dFLENBQXlDLEVBQUlHLE1BQTdDSCxDQUdGLENBQUksRUFBSUssVUFBUixDQUFvQixDQUNsQixHQUFJLEVBQUosQ0FhQSxLQVg4QixRQUExQixRQUFPLEdBQUlBLFVBV2YsQ0FUUyxFQUFRQyxVQUFSLENBQW1CLEVBQUlELFVBQXZCLENBU1QsQ0FSNkMsc0JBQWxDLE1BQVNFLElBQVQsQ0FBYyxFQUFJRixVQUFsQixDQVFYLENBUFMsR0FBSUcsV0FBSixDQUFlLEVBQUlILFVBQW5CLENBT1QsQ0FMUyxFQUFJQSxVQUtiLENBRkEsRUFBU0wsR0FBYVMsb0JBQWJULENBQWtDLEtBQUtoRSxJQUF2Q2dFLEdBRVQsQ0FBSSxNQUFKLENBQ0UsS0FBTSxJQUFJRSxNQUFKLENBQVU1RSxLQUFWLENBQU4sQ0FHRixLQUFLb0YsU0FBTCxHQUNELENBQ0YsQ0F1S0QsZUFBaUMsQ0FDL0IsR0FBSSxHQUFXLFFBQWYsQ0FLQSxHQUhBLEVBQVNDLElBQVQsTUFHQSxDQUFJLEVBQVNkLEdBQWIsQ0FBb0IsS0FBTSxHQUFTdkUsR0FBVCxFQUFnQkEsR0FBSSxFQUFTdUUsR0FBYnZFLENBQXRCLENBRXBCLE1BQU8sR0FBU3NGLE1BQ2pCLE9ENVZLQyxPQUFPQywyRkVSYixlQUF3QixDQUN0QixNQUFPQyxRQUFPQyxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ1YsSUFBaEMsS0FDUixDQU5ELEdBQUksR0FBbUMsV0FBdEIsUUFBT0MsV0FBUixFQUN3QixXQUF2QixRQUFPVSxZQURSLEVBRXVCLFdBQXRCLFFBQU9DLFdBRnhCLENBUUEsUUFBQSxDQUFpQixXQUE0QyxLQUMzRCxNQUFJLEVBQVVsSCxNQUFNK0csU0FBTixDQUFnQkksS0FBaEIsQ0FBc0JiLElBQXRCLENBQTJCYyxTQUEzQixDQUFzQyxDQUF0QyxDQUQ2QyxDQUVwRCxFQUFRdkksTUFGNEMsRUFJekQsS0FEYSxFQUFRd0ksS0FBUixFQUNiLElBRUEsR0FBc0IsUUFBbEIsVUFBSixDQUNFLEtBQU0sSUFBSUMsVUFBSixDQUFjLEVBQVMsb0JBQXZCLENBQU4sQ0FHRixJQUFLLEdBQUksRUFBVCxNQUNNLE1BRE4sR0FFSSxLQUFTLElBRmIsQ0FOQSxDQWFGLFFBQ0QsRUFJRCxXQUFBLENBQW9CLGFBQXFCLE9BQ25DLEdBQUl6SSxNQUFKLElBRG1DLEdBRW5DLEVBQUlvRyxRQUYrQixDQUVaLEVBQUlBLFFBQUosQ0FBYSxDQUFiLEdBRlksRUFHdkMsRUFBSXBHLE1BQUosRUFIdUMsR0FLeEMsS0FHRyxHQUFVLENBQ1o4QixTQUFVLG1CQUErQyxDQUN2RCxHQUFJLEVBQUlzRSxRQUFKLEVBQWdCLEVBQUtBLFFBQXpCLENBRUUsV0FEQSxHQUFLc0MsR0FBTCxDQUFTLEVBQUl0QyxRQUFKLEdBQXVCLEdBQXZCLENBQVQsR0FDQSxDQUdGLElBQUssR0FBSSxHQUFJLENBQWIsQ0FBZ0IsR0FBaEIsQ0FBeUIsR0FBekIsQ0FDRSxFQUFLLEdBQUwsRUFBc0IsRUFBSSxHQUFKLENBRXpCLENBVlcsQ0FZWnVDLGNBQWUsV0FBa0IsQ0FDL0IsR0FBSSxFQUFKLENBQU8sQ0FBUCxDQUFVLENBQVYsQ0FBZSxDQUFmLENBQW9CLENBQXBCLENBQTJCLENBQTNCLENBSUEsSUFEQSxFQUFNLENBQ04sQ0FBSyxFQUFJLENBQVQsQ0FBWSxFQUFJLEVBQU8zSSxNQUF2QixDQUErQixHQUEvQixDQUFzQyxHQUF0QyxDQUNFLEdBQU8sS0FBVUEsTUFBakIsQ0FNRixJQUZBLEVBQVMsR0FBSTBILFdBQUosR0FFVCxDQURBLEVBQU0sQ0FDTixFQUFLLEVBQUksQ0FBSixDQUFPLEVBQUksRUFBTzFILE1BQXZCLEVBQStCLEdBQS9CLENBQXNDLEdBQXRDLENBQ0UsRUFBUSxJQURWLENBRUUsRUFBTzBJLEdBQVAsS0FGRixDQUdFLEdBQU8sRUFBTTFJLE1BSGYsQ0FNQSxRQUNELENBL0JXLEVBa0NWLEVBQVksQ0FDZDhCLFNBQVUsbUJBQStDLENBQ3ZELElBQUssR0FBSSxHQUFJLENBQWIsQ0FBZ0IsR0FBaEIsQ0FBeUIsR0FBekIsQ0FDRSxFQUFLLEdBQUwsRUFBc0IsRUFBSSxHQUFKLENBRXpCLENBTGEsQ0FPZDZHLGNBQWUsV0FBa0IsQ0FDL0IsTUFBTyxHQUFHQyxNQUFILENBQVV2QyxLQUFWLE1BQ1IsQ0FUYSxFQWVoQixVQUFBLENBQW1CLFdBQWMsSUFFN0IsTUFBQSxDQUFnQnFCLFVBRmEsQ0FHN0IsT0FBQSxDQUFnQlUsV0FIYSxDQUk3QixPQUFBLENBQWdCQyxVQUphLENBSzdCLEVBQVE3QixNQUFSLEtBTDZCLEdBTzdCLE1BQUEsQ0FBZ0JyRixLQVBhLENBUTdCLE9BQUEsQ0FBZ0JBLEtBUmEsQ0FTN0IsT0FBQSxDQUFnQkEsS0FUYSxDQVU3QixFQUFRcUYsTUFBUixLQVY2QixDQVloQyxFQUVELEVBQVFxQyxRQUFSLE1KdEVJLEVBQXdCLEVBQ3hCLEVBQXdCLEVBV3hCLEVBQWUsRUFDZixHQUFlLEVBYWZ4SCxHQUFnQixHQUdoQkUsR0FBZ0IsSUFHaEJELEdBQWdCQyxHQUFXLENBQVhBLElBR2hCdUgsR0FBZ0IsR0FHaEJ2RyxHQUFnQixHQUdoQndHLEdBQWdCLEtBQWMsRUFHOUIzSCxHQUFnQixHQUdoQixHQUFnQixHQVFoQixHQUFjLEVBR2QsR0FBYyxJQUdkLEdBQWMsR0FHZCxHQUFjLEdBR2QsR0FBYyxHQUlkLCtEQUdBLHlFQUdBLDJDQUdBLG9EQWlCQSxHQUFvQkQsS0FBcEIsQ0FBMEMsQ0FBaEIsRUFBQ0csR0FBVSxDQUFYLENBQTFCLEVBQ0owSCxNQU9BLEdBQUksSUFBb0I3SCxLQUFwQixDQUFvQyxDQUFWMkgsR0FBMUIsQ0FBSixDQUNBRSxNQUtBLEdBQUksSUFBb0I3SCxLQUFwQixDQWpCZ0IsR0FpQmhCLENBQUosQ0FDQTZILE1BTUEsR0FBSSxJQUFvQjdILEtBQXBCLENBcEdlLEdBb0dXOEgsQ0FyR1gsQ0FxR1dBLENBQXdCLENBQWxELENBQUosQ0FDQUQsTUFHQSxHQUFJLElBQW9CN0gsS0FBcEIsSUFBSixDQUNBNkgsTUFHQSxHQUFJLElBQW9CN0gsS0FBcEIsSUFBSixDQUNBNkgsU0FpQkksSUFDQSxHQUNBLEdBbzBCQSxtQkFLSixXQUNBLE1BR0ksR0FISixDQUlJLEtBSkosRUFPRSxFQUFFNUcsTUFBRixDQUFZLE1BQWEsRUFBRVosU0FBZixJQVBkLENBUUUsRUFBRWEsTUFBRixDQUFZLE1BQWEsRUFBRVosU0FBZixJQVJkLENBU0UsRUFBRWEsT0FBRixDQUFZLE1BQWEsRUFBRVosT0FBZixJQVRkLENBV0UsRUFBRWIsTUFBRixDQUFXLENBWGIsQ0FZRSxFQUFFRCxRQUFGLENBQWEsQ0FaZixDQWVFLElBQ0QscUNBZ0NELGlCQUtBLElBQ00sRUFETixDQUNnQixDQURoQixDQUVNLEVBQWMsQ0FGcEIsQ0FLZ0IsQ0FBVixHQUFFMEUsS0FMUixFQVFRLEVBQUVwQyxJQUFGLENBQU8rQyxTQUFQLEdBdGhDb0IsQ0E4Z0M1QixHQVNNLEVBQUUvQyxJQUFGLENBQU8rQyxTQUFQLENBQW1CLElBVHpCLEVBYUksSUFBYyxFQUFFN0QsTUFBaEIsQ0FiSixDQWlCSSxJQUFjLEVBQUVDLE1BQWhCLENBakJKLENBMkJJLEVBQWMsSUEzQmxCLENBOEJJLEVBQVksRUFBRXBCLE9BQUYsQ0FBWSxDQUFaLENBQWdCLENBQWpCLEdBQXdCLENBOUJ2QyxDQStCSSxFQUFlLEVBQUVDLFVBQUYsQ0FBZSxDQUFmLENBQW1CLENBQXBCLEdBQTJCLENBL0I3QyxDQXFDUSxJQXJDUixHQXFDbUMsR0FyQ25DLEdBeUNJLEVBQVcsRUFBYyxFQUFhLENBekMxQyxDQTRDTyxFQUFhLENBQWIsR0FBRCxFQUF5QyxDQUFDLENBQVQsSUE1Q3ZDLENBcURJLFVBckRKLENBdURhLEVBQUU2RCxRQUFGLEdBNWtDZSxDQTRrQ2YsRUFBMEIsS0F2RHZDLEVBeURJLElBQWEsQ0FBQyxJQUFnQixDQUFqQixHQUF1QixFQUFPLENBQVAsQ0FBVyxDQUFsQyxDQUFiLENBQW1ELENBQW5ELENBekRKLENBMERJLFVBMURKLEdBNkRJLElBQWEsQ0Foa0NFLENBZ2tDRCxFQUFhLENBQWQsR0FBb0IsRUFBTyxDQUFQLENBQVcsQ0FBL0IsQ0FBYixDQUFnRCxDQUFoRCxDQTdESixDQThESSxJQUFrQixFQUFFM0MsTUFBRixDQUFTNUIsUUFBVCxDQUFvQixDQUF0QyxDQUF5QyxFQUFFNkIsTUFBRixDQUFTN0IsUUFBVCxDQUFvQixDQUE3RCxDQUFnRSxFQUFjLENBQTlFLENBOURKLENBK0RJLElBQWtCLEVBQUVnQixTQUFwQixDQUErQixFQUFFQyxTQUFqQyxDQS9ESixFQXFFRSxJQXJFRixJQXdFSSxJQUlILFlBTUQsZUFJQSxDQStDRSxNQTVDQSxHQUFFZixXQUFGLENBQWMsRUFBRXdCLEtBQUYsQ0FBdUIsQ0FBYixHQUFFUCxRQUExQixFQUE2RCxHQUFmLENBQUMsSUFBUyxDQTRDeEQsQ0EzQ0EsRUFBRWpCLFdBQUYsQ0FBYyxFQUFFd0IsS0FBRixDQUF1QixDQUFiLEdBQUVQLFFBQVosQ0FBMkIsQ0FBekMsRUFBcUQsR0FBUCxFQTJDOUMsQ0F6Q0EsRUFBRWpCLFdBQUYsQ0FBYyxFQUFFeUIsS0FBRixDQUFVLEVBQUVSLFFBQTFCLEVBQTJDLEdBQUwsRUF5Q3RDLENBeENBLEVBQUVBLFFBQUYsRUF3Q0EsQ0F0Q2EsQ0FBVCxJQXNDSixDQXBDRSxFQUFFSCxTQUFGLENBQWlCLENBQUwsRUFBWixHQW9DRixFQWxDRSxFQUFFSSxPQUFGLEVBa0NGLENBaENFLEdBZ0NGLENBM0JFLEVBQUVKLFNBQUYsQ0FBZ0QsQ0FBcEMsRUFBQyxTQUE4QixDQUEvQixDQUFaLEdBMkJGLENBMUJFLEVBQUVDLFNBQUYsQ0FBMkIsQ0FBZixLQUFaLEdBMEJGLEVBQVEsRUFBRUUsUUFBRixHQUFlLEVBQUVxRSxXQUFGLENBQWdCLENBS3hDLFlBMUpELFdBQXNCLENBQ3BCLElBQWEsSUFBZ0IsQ0FBN0IsQ0FBZ0MsQ0FBaEMsQ0FEb0IsQ0FFcEIsVUFGb0IsQ0FHcEIsSUFDRCxHS3IvQkQsT0F6QkEsaUJBQXVDLEtBQ3JDLEdBQUksR0FBdUIsQ0FBbEIsQ0FBUyxLQUFSLEVBQVYsQ0FDSSxFQUFnQyxDQUEzQixDQUFrQixLQUFqQixDQUFDLElBQVUsRUFEckIsQ0FFSSxFQUFJLENBSDZCLENBS3RCLENBQVIsSUFMOEIsRUFLbkIsQ0FJaEIsRUFBSSxXQUpZLENBS2hCLElBTGdCLENBT2hCLEVBQ0UsR0FBd0IsQ0FBbkIsQ0FBQyxFQUFLLEVBQUksR0FBSixDQURiLENBRUUsRUFBZ0IsQ0FBWCxDQUFDLEdBRlIsT0FHUyxHQUhULEVBS0EsR0FBTSxLQVpVLENBYWhCLEdBQU0sS0FDUCxDQUVELE1BQTBCLEVBQW5CLEVBQUMsRUFBTSxHQUFNLEVBQWIsQ0FDUixDQUdELElDVEksSUFmSixVQUFxQixDQUduQixPQUZJLEVBRUosQ0FGTyxJQUVQLENBQVMsRUFBSSxDQUFiLENBQW9CLEdBQUosRUFBaEIsQ0FBeUIsR0FBekIsQ0FBOEIsQ0FDNUIsR0FENEIsQ0FFNUIsSUFBSyxHQUFJLEdBQUksQ0FBYixDQUFvQixDQUFKLEVBQWhCLENBQXVCLEdBQXZCLENBQ0UsRUFBVSxDQUFKLEVBQUQsQ0FBVyxXQUFjLElBQU0sQ0FBL0IsQ0FBc0MsSUFBTSxDQUFqRCxDQUVGLE1BQ0QsQ0FFRCxRQUNELENBR2MsTUFHZixpQkFBbUMsQ0FJakMsR0FBTyxDQUFDLENBSnlCLENBTWpDLElBQUssR0FBSSxJQUFULENBQWtCLEVBSlIsR0FJVixDQUEyQixHQUEzQixDQUNFLEVBQU8sSUFBUSxDQUFULENBQWMsR0FBbUIsR0FBakIsRUFBQyxFQUFNLElBQVAsQ0FBRixDQUFwQixDQUdGLE1BQWUsQ0FBQyxDQUFSLEVBQ1QsRUNsQ0QsbUxBQUEsSU5rZ0NJLElBdi9CQWtELEdBQWtCLEVBSWxCQyxHQUFrQixFQUNsQixHQUFrQixFQU9sQkMsR0FBa0IsRUFDbEJDLEdBQWtCLEVBR2xCLEdBQWtCLENBQUMsRUFHbkIsR0FBa0IsQ0FBQyxFQVFuQkMsR0FBd0IsQ0FBQyxFQUd6QixHQUF3QixFQUN4QixHQUF3QixFQUV4QixHQUF3QixFQU94QixHQUF3QixFQUl4QkMsR0FBYyxFQUtkLEdBQWdCLEVBV2hCLEdBRmdCLEdBRUEsQ0FBVyxDQUFYLENBSkEsR0FNaEIsR0FBZ0IsR0FFaEIsR0FBZ0IsR0FFaEIsR0FBZ0IsS0FBYyxFQUU5QixHQUFZLEdBR1osR0FBWSxFQUNaLEdBQVksSUFDWixHQUFpQixNQUF3QixFQUl6QyxHQUFhLEdBQ2IsR0FBYyxHQUNkLEdBQWEsR0FDYixHQUFnQixHQUNoQixHQUFhLElBQ2IsR0FBYSxJQUNiLEdBQWUsSUFFZixHQUFvQixFQUNwQixHQUFvQixFQUNwQixHQUFvQixFQUNwQixHQUFvQixFQWk2QnhCLEdBQXNCLENBRXBCLE1BQVcsQ0FBWCxDQUFjLENBQWQsQ0FBaUIsQ0FBakIsQ0FBb0IsQ0FBcEIsQ0F4aUJGLGFBQWtDLENBSWhDLEdBQUksR0FBaUIsS0FBckIsQ0FPQSxJQUxJLEVBQWlCLEVBQUUvRCxnQkFBRixDQUFxQixDQUsxQyxHQUpFLEVBQWlCLEVBQUVBLGdCQUFGLENBQXFCLENBSXhDLElBQVMsQ0FFUCxHQUFtQixDQUFmLElBQUV0QixTQUFOLENBQXNCLENBVXBCLEdBREEsSUFDQSxDQUFvQixDQUFoQixLQUFFQSxTQUFGLEVBQXFCLE1BQXpCLENBQ0UsVUFHRixHQUFvQixDQUFoQixLQUFFQSxTQUFOLENBQ0UsS0FHSCxDQUlELEVBQUVqQixRQUFGLEVBQWMsRUFBRWlCLFNBeEJULENBeUJQLEVBQUVBLFNBQUYsQ0FBYyxDQXpCUCxDQTRCUCxHQUFJLEdBQVksRUFBRWxCLFdBQUYsRUFBaEIsQ0FFQSxJQUFtQixDQUFmLEtBQUVDLFFBQUYsRUFBb0IsRUFBRUEsUUFBRixHQUF4QixJQUVFLEVBQUVpQixTQUFGLENBQWMsRUFBRWpCLFFBQUYsRUFGaEIsQ0FHRSxFQUFFQSxRQUFGLEVBSEYsQ0FLRSxPQUxGLENBTTJCLENBQXJCLEtBQUVDLElBQUYsQ0FBT1IsU0FOYixFQU9JLFVBU0osR0FBSSxFQUFFTyxRQUFGLENBQWEsRUFBRUQsV0FBZixFQUErQixFQUFFYyxNQUFGLEdBQW5DLEdBRUUsT0FGRixDQUcyQixDQUFyQixLQUFFWixJQUFGLENBQU9SLFNBSGIsRUFJSSxTQUlMLENBakUrQixNQW1FaEMsR0FBRTZCLE1BQUYsQ0FBVyxDQW5FcUIsQ0FxRTVCLE1BckU0QixFQXVFOUIsT0F2RThCLENBd0VMLENBQXJCLEtBQUVyQixJQUFGLENBQU9SLFNBeEVtQixRQStFNUIsRUFBRU8sUUFBRixDQUFhLEVBQUVELFdBL0VhLEdBaUY5QixPQWpGOEIsQ0FrRkwsQ0FBckIsS0FBRUUsSUFBRixDQUFPUixTQWxGbUIsT0F5RmpDLENBK2NDLENBRm9CLENBR3BCLE1BQVcsQ0FBWCxDQUFjLENBQWQsQ0FBaUIsQ0FBakIsQ0FBb0IsQ0FBcEIsR0FIb0IsQ0FJcEIsTUFBVyxDQUFYLENBQWMsQ0FBZCxDQUFpQixFQUFqQixDQUFxQixDQUFyQixHQUpvQixDQUtwQixNQUFXLENBQVgsQ0FBYyxDQUFkLENBQWlCLEVBQWpCLENBQXFCLEVBQXJCLEdBTG9CLENBT3BCLE1BQVcsQ0FBWCxDQUFjLENBQWQsQ0FBaUIsRUFBakIsQ0FBcUIsRUFBckIsR0FQb0IsQ0FRcEIsTUFBVyxDQUFYLENBQWMsRUFBZCxDQUFrQixFQUFsQixDQUFzQixFQUF0QixHQVJvQixDQVNwQixNQUFXLENBQVgsQ0FBYyxFQUFkLENBQWtCLEdBQWxCLENBQXVCLEdBQXZCLEdBVG9CLENBVXBCLE1BQVcsQ0FBWCxDQUFjLEVBQWQsQ0FBa0IsR0FBbEIsQ0FBdUIsR0FBdkIsR0FWb0IsQ0FXcEIsTUFBVyxFQUFYLENBQWUsR0FBZixDQUFvQixHQUFwQixDQUF5QixJQUF6QixHQVhvQixDQVlwQixNQUFXLEVBQVgsQ0FBZSxHQUFmLENBQW9CLEdBQXBCLENBQXlCLElBQXpCLEdBWm9CLHNCQW1XdEIsYUFBa0MsQ0FDaEMsTUFBTyxVQTF5Q08sRUEweUNQLENBeHlDVyxDQXd5Q1gsQ0EzekNtQixDQTJ6Q25CLENBQ1Isb0VBeEZELGFBQXNDLE9BQ2hDLElBQVUsRUFBS0QsS0FEaUIsQ0FFWixDQUFwQixLQUFLQSxLQUFMLENBQVdhLElBRnFCLEVBR3BDLEVBQUtiLEtBQUwsQ0FBV2dELE1BQVgsRUFIb0MsVUFLckMsVUFzRkQsYUFBOEIsSUFDeEIsRUFEd0IsQ0FDYixDQURhLENBRXhCLENBRndCLENBRW5CLENBRm1CLENBSTVCLEdBQUksSUFBUyxDQUFDLEVBQUtoRCxLQUFmLEVBQ0YsSUFERSxFQUN5QixDQUFSLEVBRHJCLENBRUUsTUFBTyxHQUFPLE9BQVAsR0FBUCxDQUtGLEdBRkEsRUFBSSxFQUFLQSxLQUVULENBQUksQ0FBQyxFQUFLRSxNQUFOLEVBQ0MsQ0FBQyxFQUFLUyxLQUFOLEVBQWlDLENBQWxCLEtBQUtELFFBRHJCLEVBRUMsRUFBRW9DLE1BQUYsT0FBNkIsTUFGbEMsQ0FHRSxNQUFPLEtBQThCLENBQW5CLEtBQUs3QyxTQUFOLE1BQVYsQ0FBUCxDQVFGLEdBTEEsRUFBRVEsSUFBRixFQUtBLENBSkEsRUFBWSxFQUFFMEMsVUFJZCxDQUhBLEVBQUVBLFVBQUYsRUFHQSxDQUFJLEVBQUVMLE1BQUYsS0FBSixDQUVFLEdBQWUsQ0FBWCxLQUFFakMsSUFBTixDQUNFLEVBQUtDLEtBQUwsQ0FBYSxDQURmLENBRUUsSUFBWSxFQUFaLENBRkYsQ0FHRSxJQUFZLEdBQVosQ0FIRixDQUlFLElBQVksQ0FBWixDQUpGLENBS08sRUFBRWtDLE1BTFQsRUFrQkksSUFBWSxDQUFDLEVBQUVBLE1BQUYsQ0FBUytELElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0IsQ0FBckIsR0FDQyxFQUFFL0QsTUFBRixDQUFTZ0UsSUFBVCxDQUFnQixDQUFoQixDQUFvQixDQURyQixHQUVFLEVBQUVoRSxNQUFGLENBQVNpRSxLQUFWLENBQXNCLENBQXRCLENBQWtCLENBRm5CLEdBR0UsRUFBRWpFLE1BQUYsQ0FBU2tFLElBQVYsQ0FBcUIsQ0FBckIsQ0FBaUIsQ0FIbEIsR0FJRSxFQUFFbEUsTUFBRixDQUFTbUUsT0FBVixDQUF3QixFQUF4QixDQUFvQixDQUpyQixDQUFaLENBbEJKLENBd0JJLElBQTRCLEdBQWhCLEdBQUVuRSxNQUFGLENBQVNvRSxJQUFyQixDQXhCSixDQXlCSSxJQUFtQyxHQUF2QixDQUFDLEVBQUVwRSxNQUFGLENBQVNvRSxJQUFULEVBQWlCLENBQTlCLENBekJKLENBMEJJLElBQW9DLEdBQXhCLENBQUMsRUFBRXBFLE1BQUYsQ0FBU29FLElBQVQsRUFBaUIsRUFBOUIsQ0ExQkosQ0EyQkksSUFBb0MsR0FBeEIsQ0FBQyxFQUFFcEUsTUFBRixDQUFTb0UsSUFBVCxFQUFpQixFQUE5QixDQTNCSixDQTRCSSxJQUF3QixDQUFaLEtBQUV2RSxLQUFGLENBQWdCLENBQWhCLENBQ0MsRUFBRVAsUUFBRixNQUEwQyxDQUFWLEdBQUVPLEtBQWxDLENBQ0EsQ0FEQSxDQUNJLENBRmpCLENBNUJKLENBK0JJLElBQTBCLEdBQWQsR0FBRUcsTUFBRixDQUFTcUUsRUFBckIsQ0EvQkosQ0FnQ1EsRUFBRXJFLE1BQUYsQ0FBU2lFLEtBQVQsRUFBa0IsRUFBRWpFLE1BQUYsQ0FBU2lFLEtBQVQsQ0FBZTFKLE1BaEN6QyxHQWlDTSxJQUFvQyxHQUF4QixHQUFFeUYsTUFBRixDQUFTaUUsS0FBVCxDQUFlMUosTUFBM0IsQ0FqQ04sQ0FrQ00sSUFBMkMsR0FBL0IsQ0FBQyxFQUFFeUYsTUFBRixDQUFTaUUsS0FBVCxDQUFlMUosTUFBZixFQUF5QixDQUF0QyxDQWxDTixFQW9DUSxFQUFFeUYsTUFBRixDQUFTZ0UsSUFwQ2pCLEdBcUNNLEVBQUtsRyxLQUFMLENBQWFFLEdBQU0sRUFBS0YsS0FBWEUsQ0FBa0IsRUFBRS9DLFdBQXBCK0MsQ0FBaUMsRUFBRTlDLE9BQW5DOEMsQ0FBNEMsQ0FBNUNBLENBckNuQixFQXVDSSxFQUFFaUMsT0FBRixDQUFZLENBdkNoQixDQXdDSSxFQUFFSCxNQUFGLEdBeENKLEdBTUksSUFBWSxDQUFaLENBTkosQ0FPSSxJQUFZLENBQVosQ0FQSixDQVFJLElBQVksQ0FBWixDQVJKLENBU0ksSUFBWSxDQUFaLENBVEosQ0FVSSxJQUFZLENBQVosQ0FWSixDQVdJLElBQXdCLENBQVosS0FBRUQsS0FBRixDQUFnQixDQUFoQixDQUNDLEVBQUVQLFFBQUYsTUFBMEMsQ0FBVixHQUFFTyxLQUFsQyxDQUNBLENBREEsQ0FDSSxDQUZqQixDQVhKLENBY0ksTUFkSixDQWVJLEVBQUVDLE1BQUYsR0FmSixNQTRDQSxJQUNNLEdBQVVnRSxJQUFlLEVBQUUxRCxNQUFGLENBQVcsQ0FBWixFQUFrQixDQUFoQzBELENBQUQsRUFBd0MsQ0FEdkQsQ0FFTSxFQUFjLENBQUMsQ0FGckIsR0FJTSxFQUFFeEUsUUFBRixNQUEwQyxDQUFWLEdBQUVPLEtBSnhDLENBS2tCLENBTGxCLENBTXVCLENBQVYsR0FBRUEsS0FOZixDQU9rQixDQVBsQixDQVF5QixDQUFaLEtBQUVBLEtBUmYsQ0FTa0IsQ0FUbEIsQ0FXa0IsQ0FYbEIsQ0FhRSxHQUFXLEdBQWUsQ0FiNUIsQ0FjcUIsQ0FBZixLQUFFckMsUUFkUixHQWMwQixHQXgyQ1osRUEwMUNkLEVBZUUsR0FBVSxHQUFNLEVBQVMsRUFmM0IsQ0FpQkUsRUFBRXNDLE1BQUYsR0FqQkYsQ0FrQkUsTUFsQkYsQ0FxQnFCLENBQWYsS0FBRXRDLFFBckJSLEdBc0JJLElBQWUsRUFBS00sS0FBTCxHQUFlLEVBQTlCLENBdEJKLENBdUJJLElBQTRCLEtBQWIsR0FBS0EsS0FBcEIsQ0F2QkosRUF5QkUsRUFBS0EsS0FBTCxDQUFhLENBQ2QsQ0FJSCxHQUFJLEVBQUVnQyxNQUFGLEtBQUosQ0FDRSxHQUFJLEVBQUVFLE1BQUYsQ0FBU2lFLEtBQWIsQ0FBa0MsS0FDaEMsRUFBTSxFQUFFL0ksT0FEd0IsQ0FHekIsRUFBRStFLE9BQUYsRUFBcUMsS0FBeEIsR0FBRUQsTUFBRixDQUFTaUUsS0FBVCxDQUFlMUosTUFBNUIsQ0FIeUIsSUFJMUIsRUFBRVcsT0FBRixHQUFjLEVBQUU2RSxnQkFKVSxHQUt4QixFQUFFQyxNQUFGLENBQVNnRSxJQUFULEVBQWlCLEVBQUU5SSxPQUFGLEVBTE8sR0FNMUIsRUFBSzRDLEtBQUwsQ0FBYUUsR0FBTSxFQUFLRixLQUFYRSxDQUFrQixFQUFFL0MsV0FBcEIrQyxDQUFpQyxFQUFFOUMsT0FBRixFQUFqQzhDLEdBTmEsRUFRNUIsSUFSNEIsQ0FTNUIsRUFBTSxFQUFFOUMsT0FUb0IsQ0FVeEIsRUFBRUEsT0FBRixHQUFjLEVBQUU2RSxnQkFWUSxJQWM5QixJQUF3QyxHQUE1QixHQUFFQyxNQUFGLENBQVNpRSxLQUFULENBQWUsRUFBRWhFLE9BQWpCLENBQVosQ0FkOEIsQ0FlOUIsRUFBRUEsT0FBRixFQWY4QixDQWlCNUIsRUFBRUQsTUFBRixDQUFTZ0UsSUFBVCxFQUFpQixFQUFFOUksT0FBRixFQWpCVyxHQWtCOUIsRUFBSzRDLEtBQUwsQ0FBYUUsR0FBTSxFQUFLRixLQUFYRSxDQUFrQixFQUFFL0MsV0FBcEIrQyxDQUFpQyxFQUFFOUMsT0FBRixFQUFqQzhDLEdBbEJpQixFQW9CNUIsRUFBRWlDLE9BQUYsR0FBYyxFQUFFRCxNQUFGLENBQVNpRSxLQUFULENBQWUxSixNQXBCRCxHQXFCOUIsRUFBRTBGLE9BQUYsQ0FBWSxDQXJCa0IsQ0FzQjlCLEVBQUVILE1BQUYsR0F0QjhCLENBd0JqQyxDQXhCRCxJQTBCRSxHQUFFQSxNQUFGLEdBMUJGLENBNkJGLEdBQUksRUFBRUEsTUFBRixLQUFKLENBQ0UsR0FBSSxFQUFFRSxNQUFGLENBQVNrRSxJQUFiLENBQWlDLENBQy9CLEVBQU0sRUFBRWhKLE9BRHVCLENBSS9CLEVBQUcsQ0FDRCxHQUFJLEVBQUVBLE9BQUYsR0FBYyxFQUFFNkUsZ0JBQXBCLEdBQ00sRUFBRUMsTUFBRixDQUFTZ0UsSUFBVCxFQUFpQixFQUFFOUksT0FBRixFQUR2QixHQUVJLEVBQUs0QyxLQUFMLENBQWFFLEdBQU0sRUFBS0YsS0FBWEUsQ0FBa0IsRUFBRS9DLFdBQXBCK0MsQ0FBaUMsRUFBRTlDLE9BQUYsRUFBakM4QyxHQUZqQixFQUlFLElBSkYsQ0FLRSxFQUFNLEVBQUU5QyxPQUxWLENBTU0sRUFBRUEsT0FBRixHQUFjLEVBQUU2RSxnQkFOdEIsRUFNd0MsQ0FDcEMsRUFBTSxDQUQ4QixDQUVwQyxLQUNELENBVkYsRUFhRyxFQUFFRSxPQUFGLENBQVksRUFBRUQsTUFBRixDQUFTa0UsSUFBVCxDQUFjM0osTUFiN0IsQ0FjK0MsR0FBeEMsR0FBRXlGLE1BQUYsQ0FBU2tFLElBQVQsQ0FBY0ksVUFBZCxDQUF5QixFQUFFckUsT0FBRixFQUF6QixDQWRQLENBZ0JPLENBaEJQLENBa0JELE1BQ0QsQ0FuQkQsTUFtQmlCLENBQVIsSUFuQlQsRUFxQkksRUFBRUQsTUFBRixDQUFTZ0UsSUFBVCxFQUFpQixFQUFFOUksT0FBRixFQXpCVSxHQTBCN0IsRUFBSzRDLEtBQUwsQ0FBYUUsR0FBTSxFQUFLRixLQUFYRSxDQUFrQixFQUFFL0MsV0FBcEIrQyxDQUFpQyxFQUFFOUMsT0FBRixFQUFqQzhDLEdBMUJnQixFQTRCbkIsQ0FBUixJQTVCMkIsR0E2QjdCLEVBQUVpQyxPQUFGLENBQVksQ0E3QmlCLENBOEI3QixFQUFFSCxNQUFGLEdBOUI2QixDQWdDaEMsQ0FoQ0QsSUFrQ0UsR0FBRUEsTUFBRixHQWxDRixDQXFDRixHQUFJLEVBQUVBLE1BQUYsS0FBSixDQUNFLEdBQUksRUFBRUUsTUFBRixDQUFTbUUsT0FBYixDQUFvQyxDQUNsQyxFQUFNLEVBQUVqSixPQUQwQixDQUlsQyxFQUFHLENBQ0QsR0FBSSxFQUFFQSxPQUFGLEdBQWMsRUFBRTZFLGdCQUFwQixHQUNNLEVBQUVDLE1BQUYsQ0FBU2dFLElBQVQsRUFBaUIsRUFBRTlJLE9BQUYsRUFEdkIsR0FFSSxFQUFLNEMsS0FBTCxDQUFhRSxHQUFNLEVBQUtGLEtBQVhFLENBQWtCLEVBQUUvQyxXQUFwQitDLENBQWlDLEVBQUU5QyxPQUFGLEVBQWpDOEMsR0FGakIsRUFJRSxJQUpGLENBS0UsRUFBTSxFQUFFOUMsT0FMVixDQU1NLEVBQUVBLE9BQUYsR0FBYyxFQUFFNkUsZ0JBTnRCLEVBTXdDLENBQ3BDLEVBQU0sQ0FEOEIsQ0FFcEMsS0FDRCxDQVZGLEVBYUcsRUFBRUUsT0FBRixDQUFZLEVBQUVELE1BQUYsQ0FBU21FLE9BQVQsQ0FBaUI1SixNQWJoQyxDQWNrRCxHQUEzQyxHQUFFeUYsTUFBRixDQUFTbUUsT0FBVCxDQUFpQkcsVUFBakIsQ0FBNEIsRUFBRXJFLE9BQUYsRUFBNUIsQ0FkUCxDQWdCTyxDQWhCUCxDQWtCRCxNQUNELENBbkJELE1BbUJpQixDQUFSLElBbkJULEVBcUJJLEVBQUVELE1BQUYsQ0FBU2dFLElBQVQsRUFBaUIsRUFBRTlJLE9BQUYsRUF6QmEsR0EwQmhDLEVBQUs0QyxLQUFMLENBQWFFLEdBQU0sRUFBS0YsS0FBWEUsQ0FBa0IsRUFBRS9DLFdBQXBCK0MsQ0FBaUMsRUFBRTlDLE9BQUYsRUFBakM4QyxHQTFCbUIsRUE0QnRCLENBQVIsSUE1QjhCLEdBNkJoQyxFQUFFOEIsTUFBRixHQTdCZ0MsQ0ErQm5DLENBL0JELElBaUNFLEdBQUVBLE1BQUYsR0FqQ0YsQ0F1REYsR0FuQkksRUFBRUEsTUFBRixLQW1CSixHQWxCTSxFQUFFRSxNQUFGLENBQVNnRSxJQWtCZixFQWpCUSxFQUFFOUksT0FBRixDQUFZLENBQVosQ0FBZ0IsRUFBRTZFLGdCQWlCMUIsRUFoQk0sSUFnQk4sQ0FkUSxFQUFFN0UsT0FBRixDQUFZLENBQVosRUFBaUIsRUFBRTZFLGdCQWMzQixHQWJNLElBQXlCLEdBQWIsR0FBS2pDLEtBQWpCLENBYU4sQ0FaTSxJQUFnQyxHQUFwQixDQUFDLEVBQUtBLEtBQUwsRUFBYyxDQUEzQixDQVlOLENBWE0sRUFBS0EsS0FBTCxDQUFhLENBV25CLENBVk0sRUFBRWdDLE1BQUYsR0FVTixHQU5JLEVBQUVBLE1BQUYsR0FNSixFQUFrQixDQUFkLEtBQUU1RSxPQUFOLEVBRUUsR0FEQSxJQUNBLENBQXVCLENBQW5CLEtBQUsrQixTQUFULENBUUUsTUFEQSxHQUFFa0QsVUFBRixDQUFlLENBQUMsQ0FDaEIsSUFWSixLQWlCTyxJQUFzQixDQUFsQixLQUFLekMsUUFBTCxFQUF1QixNQUFlLElBQXRDLEVBQ1QsTUFESyxDQUVMLE1BQU8sUUFBUCxDQUlGLEdBQUksRUFBRW9DLE1BQUYsT0FBK0MsQ0FBbEIsS0FBS3BDLFFBQXRDLENBQ0UsTUFBTyxRQUFQLENBS0YsR0FBc0IsQ0FBbEIsS0FBS0EsUUFBTCxFQUF1QyxDQUFoQixLQUFFZSxTQUF6QixFQUNELFFBQXdCLEVBQUVxQixNQUFGLEtBRDNCLENBQ3VELENBQ3JELEdBQUksR0FBVSxFQUFFUixRQUFGLEtBQUQsQ0FBa0MsTUFBbEMsQ0FDVixFQUFFQSxRQUFGLEdBL2pEcUIsQ0ErakRyQixDQUF1QixNQUF2QixDQUNDLEdBQW9CLEVBQUVPLEtBQXRCLEVBQTZCRCxJQUE3QixLQUZKLENBT0EsSUFISSxRQUFnQyxNQUdwQyxJQUZFLEVBQUVFLE1BQUYsR0FFRixFQUFJLFFBQTJCLE1BQS9CLENBS0UsTUFKdUIsRUFBbkIsS0FBSzdDLFNBSVQsR0FIRSxFQUFFa0QsVUFBRixDQUFlLENBQUMsQ0FHbEIsS0FTRixHQUFJLE1BQUosR0FDTSxJQW5uRFksQ0FrbkRsQixDQUVJLEdBQU1vRSxTQUFOLEdBRkosQ0FJVyxNQUpYLEdBTUksR0FBTUMsZ0JBQU4sR0FBMEIsQ0FBMUIsQ0FBNkIsQ0FBN0IsSUFOSixDQVVRLElBMW5EVSxDQWduRGxCLEdBWU0sRUFBSyxFQUFFM0YsSUFBUCxDQVpOLENBYzBCLENBQWhCLEtBQUVKLFNBZFosR0FlUSxFQUFFakIsUUFBRixDQUFhLENBZnJCLENBZ0JRLEVBQUVELFdBQUYsQ0FBZ0IsQ0FoQnhCLENBaUJRLEVBQUV1QixNQUFGLENBQVcsQ0FqQm5CLElBcUJFLElBckJGLENBc0J5QixDQUFuQixLQUFLN0IsU0F0QlgsRUF3QkksTUFEQSxHQUFFa0QsVUFBRixDQUFlLENBQUMsQ0FDaEIsR0FHTCxDQTdTMkIsTUFpVHhCLE9BalR3QixDQWtUZCxDQUFWLElBQUV0QyxJQWxUc0IsS0FxVGIsQ0FBWCxLQUFFQSxJQXJUc0IsRUFzVDFCLElBQXlCLEdBQWIsR0FBS0MsS0FBakIsQ0F0VDBCLENBdVQxQixJQUFnQyxHQUFwQixDQUFDLEVBQUtBLEtBQUwsRUFBYyxDQUEzQixDQXZUMEIsQ0F3VDFCLElBQWlDLEdBQXJCLENBQUMsRUFBS0EsS0FBTCxFQUFjLEVBQTNCLENBeFQwQixDQXlUMUIsSUFBaUMsR0FBckIsQ0FBQyxFQUFLQSxLQUFMLEVBQWMsRUFBM0IsQ0F6VDBCLENBMFQxQixJQUE0QixHQUFoQixHQUFLRyxRQUFqQixDQTFUMEIsQ0EyVDFCLElBQW1DLEdBQXZCLENBQUMsRUFBS0EsUUFBTCxFQUFpQixDQUE5QixDQTNUMEIsQ0E0VDFCLElBQW9DLEdBQXhCLENBQUMsRUFBS0EsUUFBTCxFQUFpQixFQUE5QixDQTVUMEIsQ0E2VDFCLElBQW9DLEdBQXhCLENBQUMsRUFBS0EsUUFBTCxFQUFpQixFQUE5QixDQTdUMEIsR0FpVTFCLElBQWUsRUFBS0gsS0FBTCxHQUFlLEVBQTlCLENBalUwQixDQWtVMUIsSUFBNEIsS0FBYixHQUFLQSxLQUFwQixDQWxVMEIsRUFxVTVCLElBclU0QixDQXlVZixDQUFULEdBQUVELElBelVzQixHQXlVVixFQUFFQSxJQUFGLENBQVMsQ0FBQyxFQUFFQSxJQXpVRixFQTJVUCxDQUFkLEtBQUUzQyxPQUFGLE1BM1VxQixJQTRVN0IsYUFFRCxXQUEwQixDQUN4QixHQUFJLEVBQUosQ0FEd0IsTUFHcEIsSUFBdUIsRUFBSzhCLEtBSFIsRUFPeEIsRUFBUyxFQUFLQSxLQUFMLENBQVc4QyxNQVBJLENBUXBCLFFBQ0YsTUFERSxFQUVGLE1BRkUsRUFHRixNQUhFLEVBSUYsTUFKRSxFQUtGLE1BTEUsRUFNRixNQWRzQixFQWdCZixPQWhCZSxFQW1CeEIsRUFBSzlDLEtBQUwsQ0FBYSxJQW5CVyxDQXFCakIsT0FBd0IsSUFuckRYLENBQUMsQ0FtckRVLENBQXhCLEdBckJpQixJQXNCekIsdUJBT0QsYUFBZ0QsSUFHMUMsRUFIMEMsQ0FJMUMsQ0FKMEMsQ0FJckMsQ0FKcUMsQ0FLMUMsQ0FMMEMsQ0FNMUMsQ0FOMEMsQ0FPMUMsQ0FQMEMsQ0FRMUMsQ0FSMEMsQ0FTMUMsQ0FUMEMsQ0FDMUMsRUFBYSxFQUFXekMsTUFEa0IsQ0FXOUMsR0FBSSxJQUFzQixDQUFDLEVBQUt5QyxLQUFoQyxDQUNFLFVBTUYsR0FIQSxFQUFJLEVBQUtBLEtBR1QsQ0FGQSxFQUFPLEVBQUVhLElBRVQsQ0FBYSxDQUFULE1BQXdCLENBQVQsTUFBYyxFQUFFaUMsTUFBRixLQUE3QixFQUF5RCxFQUFFckIsU0FBL0QsQ0FDRSxVQW5CNEMsSUF1QmpDLENBQVQsSUF2QjBDLEdBeUI1QyxFQUFLWCxLQUFMLENBQWFDLEdBQVEsRUFBS0QsS0FBYkMsS0FBNEMsQ0FBNUNBLENBekIrQixFQTRCOUMsRUFBRUYsSUFBRixDQUFTLENBNUJxQyxDQStCMUMsR0FBYyxFQUFFUSxNQS9CMEIsR0FnQy9CLENBQVQsSUFoQ3dDLEdBa0MxQyxFQUFLLEVBQUVRLElBQVAsQ0FsQzBDLENBbUMxQyxFQUFFckIsUUFBRixDQUFhLENBbkM2QixDQW9DMUMsRUFBRUQsV0FBRixDQUFnQixDQXBDMEIsQ0FxQzFDLEVBQUV1QixNQUFGLENBQVcsQ0FyQytCLEVBeUM1QyxFQUFVLEdBQUkxQyxHQUFNc0UsSUFBVixDQUFlLEVBQUVyQyxNQUFqQixDQXpDa0MsQ0EwQzVDakMsRUFBTUMsUUFBTkQsS0FBb0MsRUFBYSxFQUFFaUMsTUFBbkRqQyxDQUEyRCxFQUFFaUMsTUFBN0RqQyxDQUFxRSxDQUFyRUEsQ0ExQzRDLENBMkM1QyxHQTNDNEMsQ0E0QzVDLEVBQWEsRUFBRWlDLE1BNUM2QixFQStDOUMsRUFBUSxFQUFLWCxRQS9DaUMsQ0FnRDlDLEVBQU8sRUFBS0UsT0FoRGtDLENBaUQ5QyxFQUFRLEVBQUtELEtBakRpQyxDQWtEOUMsRUFBS0QsUUFBTCxFQWxEOEMsQ0FtRDlDLEVBQUtFLE9BQUwsQ0FBZSxDQW5EK0IsQ0FvRDlDLEVBQUtELEtBQUwsRUFwRDhDLENBcUQ5QyxJQXJEOEMsQ0FzRHZDLEVBQUVjLFNBQUYsSUF0RHVDLEVBc0RiLENBQy9CLEVBQU0sRUFBRWpCLFFBRHVCLENBRS9CLEVBQUksRUFBRWlCLFNBQUYsRUFBZSxHQUFZLENBQTNCLENBRjJCLENBRy9CLEVBRUUsR0FBRU0sS0FBRixDQUFVLENBQUUsRUFBRUEsS0FBRixFQUFXLEVBQUVDLFVBQWQsQ0FBNEIsRUFBRTFDLE1BQUYsQ0FBUyxLQUFrQixDQUEzQixDQUE3QixFQUE4RCxFQUFFMkMsU0FGNUUsQ0FJRSxFQUFFVixJQUFGLENBQU8sRUFBTSxFQUFFRCxNQUFmLEVBQXlCLEVBQUVPLElBQUYsQ0FBTyxFQUFFRSxLQUFULENBSjNCLENBTUUsRUFBRUYsSUFBRixDQUFPLEVBQUVFLEtBQVQsR0FORixDQU9FLEdBUEYsT0FRUyxHQVJULEVBU0EsRUFBRXZCLFFBQUYsRUFaK0IsQ0FhL0IsRUFBRWlCLFNBQUYsQ0FBYyxHQUFZLENBYkssQ0FjL0IsSUFDRCxDQVdELE1BVkEsR0FBRWpCLFFBQUYsRUFBYyxFQUFFaUIsU0FVaEIsQ0FUQSxFQUFFbEIsV0FBRixDQUFnQixFQUFFQyxRQVNsQixDQVJBLEVBQUVzQixNQUFGLENBQVcsRUFBRUwsU0FRYixDQVBBLEVBQUVBLFNBQUYsQ0FBYyxDQU9kLENBTkEsRUFBRVMsWUFBRixDQUFpQixFQUFFZixXQUFGLENBQWdCLEdBQVksQ0FNN0MsQ0FMQSxFQUFFb0IsZUFBRixDQUFvQixDQUtwQixDQUpBLEVBQUszQixPQUFMLEVBSUEsQ0FIQSxFQUFLRCxLQUFMLEVBR0EsQ0FGQSxFQUFLRCxRQUFMLEVBRUEsQ0FEQSxFQUFFRyxJQUFGLEVBQ0EsR0FDRCxjQVdxQix5Q0M1ekRsQixPQUNBLE1BRUosR0FBSSxDQUFFLEVBQW9CK0MsS0FBcEIsQ0FBMEIsSUFBMUIsS0FBeUMsQ0FBQyxRQUFXLENBQUUsS0FBdUIsQ0FDcEYsR0FBSSxDQUFFLEVBQW9CQSxLQUFwQixDQUEwQixJQUExQixDQUFnQyxHQUFJcUIsV0FBSixDQUFlLENBQWYsQ0FBaEMsQ0FBcUQsQ0FBQyxRQUFXLENBQUUsS0FBMkIsQ0FPcEcsT0FESSxJQUFXLEdBQUk3RixHQUFNc0UsSUFBVixDQUFlLEdBQWYsQ0FDZixDQUFTLEdBQUksQ0FBYixDQUFvQixHQUFKLEdBQWhCLENBQXlCLElBQXpCLENBQ0UsT0FBb0IsR0FBTCxLQUFXLENBQVgsQ0FBb0IsR0FBTCxLQUFXLENBQVgsQ0FBb0IsR0FBTCxLQUFXLENBQVgsQ0FBb0IsR0FBTCxLQUFXLENBQVgsQ0FBb0IsR0FBTCxLQUFXLENBQVgsQ0FBZSxDQUExRixDQUVGLEdBQVMsR0FBVCxFQUFnQixHQUFTLEdBQVQsRUFBZ0Isb0JBSVgsV0FBZSxDQUNsQyxHQUFJLEVBQUosQ0FBUyxDQUFULENBQVksQ0FBWixDQUFnQixDQUFoQixDQUF1QixDQUF2QixDQUEwQixFQUFVLEVBQUluRyxNQUF4QyxDQUFnRCxFQUFVLENBQTFELENBR0EsSUFBSyxFQUFRLENBQWIsQ0FBZ0IsR0FBaEIsQ0FBaUMsR0FBakMsQ0FDRSxFQUFJLEVBQUkrSixVQUFKLEdBRE4sQ0FFdUIsS0FBakIsR0FBSyxLQUFKLEVBQUQsR0FBNEIsRUFBUSxDQUFSLEVBRmxDLEdBR0ksRUFBSyxFQUFJQSxVQUFKLENBQWUsRUFBUSxDQUF2QixDQUhULENBSTBCLEtBQWxCLEdBQU0sS0FBTCxFQUFELENBSlIsR0FLTSxFQUFJLE9BQVksRUFBSSxLQUFMLEVBQWdCLEVBQTNCLEdBQWtDLEVBQUssS0FBdkMsQ0FMVixDQU1NLEdBTk4sR0FTRSxHQUFlLEdBQUosR0FBVyxDQUFYLENBQW1CLElBQUosR0FBWSxDQUFaLENBQW9CLEtBQUosR0FBYyxDQUFkLENBQWtCLENBVDlELENBZ0JBLElBSEEsRUFBTSxHQUFJbEksR0FBTXNFLElBQVYsR0FHTixDQUFLLEVBQUksQ0FBVCxDQUFZLEVBQVEsQ0FBcEIsQ0FBdUIsR0FBdkIsQ0FBb0MsR0FBcEMsQ0FDRSxFQUFJLEVBQUk0RCxVQUFKLEdBRE4sQ0FFdUIsS0FBakIsR0FBSyxLQUFKLEVBQUQsR0FBNEIsRUFBUSxDQUFSLEVBRmxDLEdBR0ksRUFBSyxFQUFJQSxVQUFKLENBQWUsRUFBUSxDQUF2QixDQUhULENBSTBCLEtBQWxCLEdBQU0sS0FBTCxFQUFELENBSlIsR0FLTSxFQUFJLE9BQVksRUFBSSxLQUFMLEVBQWdCLEVBQTNCLEdBQWtDLEVBQUssS0FBdkMsQ0FMVixDQU1NLEdBTk4sR0FTVSxHQUFKLEVBVE4sQ0FXSSxFQUFJLEdBQUosR0FYSixDQVlpQixJQUFKLEVBWmIsRUFjSSxFQUFJLEdBQUosRUFBVyxJQUFRLElBQU0sQ0FkN0IsQ0FlSSxFQUFJLEdBQUosRUFBVyxJQUFZLEVBQUosRUFmdkIsRUFnQmlCLEtBQUosRUFoQmIsRUFrQkksRUFBSSxHQUFKLEVBQVcsSUFBUSxJQUFNLEVBbEI3QixDQW1CSSxFQUFJLEdBQUosRUFBVyxJQUFrQixFQUFWLEtBQU0sQ0FuQjdCLENBb0JJLEVBQUksR0FBSixFQUFXLElBQVksRUFBSixFQXBCdkIsR0F1QkksRUFBSSxHQUFKLEVBQVcsSUFBUSxJQUFNLEVBdkI3QixDQXdCSSxFQUFJLEdBQUosRUFBVyxJQUFtQixFQUFYLEtBQU0sRUF4QjdCLENBeUJJLEVBQUksR0FBSixFQUFXLElBQWtCLEVBQVYsS0FBTSxDQXpCN0IsQ0EwQkksRUFBSSxHQUFKLEVBQVcsSUFBWSxFQUFKLEVBMUJ2QixFQThCQSxRQUNELGdCQW9CdUIsV0FBZSxDQUNyQyxNQUFPLEtBQW1CLEVBQUkvSixNQUF2QixDQUNSLGdCQUl1QixXQUFlLENBRXJDLE9BREksR0FBTSxHQUFJNkIsR0FBTXNFLElBQVYsQ0FBZSxFQUFJbkcsTUFBbkIsQ0FDVixDQUFTLEVBQUksQ0FBYixDQUFnQixFQUFNLEVBQUlBLE1BQTFCLENBQWtDLEdBQWxDLENBQTJDLEdBQTNDLENBQ0UsS0FBUyxFQUFJK0osVUFBSixHQUFULENBRUYsUUFDRCxhQUlvQixhQUFvQixJQUNuQyxFQURtQyxDQUNoQyxDQURnQyxDQUMzQixDQUQyQixDQUN4QixDQUR3QixDQUVuQyxFQUFNLEdBQU8sRUFBSS9KLE1BRmtCLENBT25DLEVBQWVtQixLQUFmLENBQTJCLENBQU4sRUFBckIsQ0FQbUMsQ0FTdkMsSUFBSyxFQUFNLENBQU4sQ0FBUyxFQUFJLENBQWxCLENBQXFCLEdBQXJCLEVBQStCLENBRzdCLEdBRkEsRUFBSSxFQUFJLEdBQUosQ0FFSixDQUFRLEdBQUosRUFBSixDQUFjLENBQUUsRUFBUyxHQUFULEdBQUYsQ0FBdUIsUUFBVyxDQUloRCxHQUZBLEVBQVEsS0FFUixDQUFZLENBQVIsRUFBSixDQUFlLENBQUUsRUFBUyxHQUFULEVBQWtCLEtBQXBCLENBQTRCLEdBQUssRUFBUSxDQUF6QyxDQUE0QyxRQUFXLENBUHpDLElBVTdCLEdBQWUsQ0FBVixLQUFjLEVBQWQsQ0FBK0IsQ0FBVixLQUFjLEVBQWQsRUFWRyxDQVlkLENBQVIsSUFBYSxHQVpTLEVBYTNCLEVBQUssR0FBSyxDQUFOLENBQXVCLEVBQVgsR0FBSSxHQUFKLENBYlcsQ0FjM0IsR0FkMkIsQ0FrQjdCLEdBQVksQ0FBUixFQUFKLENBQWUsQ0FBRSxFQUFTLEdBQVQsRUFBa0IsS0FBcEIsQ0FBNEIsUUFBVyxDQUU5QyxLQUFKLEVBcEJ5QixDQXFCM0IsRUFBUyxHQUFULEdBckIyQixFQXVCM0IsR0FBSyxLQXZCc0IsQ0F3QjNCLEVBQVMsR0FBVCxFQUFrQixNQUFzQixJQUFaLENBQUMsR0FBSyxFQXhCUCxDQXlCM0IsRUFBUyxHQUFULEVBQWtCLE1BQWMsSUFBSixFQXpCRCxDQTJCOUIsQ0FFRCxNQUFPLE9BQ1IsYUFTb0IsYUFBb0IsQ0FDdkMsR0FBSSxFQUFKLENBRHVDLElBR3ZDLEVBQU0sR0FBTyxFQUFJbkIsTUFIc0IsQ0FJbkMsRUFBTSxFQUFJQSxNQUp5QixHQUlmLEVBQU0sRUFBSUEsTUFKSyxFQU92QyxFQUFNLEVBQU0sQ0FQMkIsQ0FRekIsQ0FBUCxLQUFrQyxHQUF0QixHQUFZLEdBQVgsS0FBRCxDQVJvQixFQVFVLElBUlYsTUFZN0IsRUFBTixFQVptQyxHQWdCM0IsQ0FBUixJQWhCbUMsR0FrQi9CLEVBQU0sR0FBUyxJQUFULENBQU4sRUFBRCxJQUNSLEdNMUlELE9BekJBLFVBQW1CLENBRWpCLEtBQUtvRCxLQUFMLENBQWEsSUFGSSxDQUdqQixLQUFLQyxPQUFMLENBQWUsQ0FIRSxDQUtqQixLQUFLRixRQUFMLENBQWdCLENBTEMsQ0FPakIsS0FBS08sUUFBTCxDQUFnQixDQVBDLENBU2pCLEtBQUtmLE1BQUwsQ0FBYyxJQVRHLENBVWpCLEtBQUtFLFFBQUwsQ0FBZ0IsQ0FWQyxDQVlqQixLQUFLSCxTQUFMLENBQWlCLENBWkEsQ0FjakIsS0FBS0ksU0FBTCxDQUFpQixDQWRBLENBZ0JqQixLQUFLTixHQUFMLENBQVcsRUFoQk0sQ0FrQmpCLEtBQUtDLEtBQUwsQ0FBYSxJQWxCSSxDQW9CakIsS0FBS3dELFNBQUwsQ0FBaUIsQ0FwQkEsQ0FzQmpCLEtBQUsxQyxLQUFMLENBQWEsQ0FDZCxDQUVELElMckNJLElBQVcwRSxPQUFPQyxTQUFQLENBQWlCZ0MsU0FNNUIsR0FBa0IsRUFFbEIsR0FBa0IsRUFDbEIsR0FBa0IsRUFDbEIsR0FBa0IsRUFFbEIsR0FBd0IsQ0FBQyxFQUV6QixHQUF3QixFQUV4QixHQUFjLEVBaU1sQixFQUFRaEMsU0FBUixDQUFrQkwsSUFBbEIsQ0FBeUIsYUFBc0IsSUFHekMsRUFIeUMsQ0FHakMsQ0FIaUMsQ0FDekMsRUFBTyxLQUFLM0UsSUFENkIsQ0FFekMsRUFBWSxLQUFLcUQsT0FBTCxDQUFhRSxTQUZnQixDQUs3QyxHQUFJLEtBQUtPLEtBQVQsQ0FBa0IsU0FFbEIsRUFBUyxJQUFTLENBQUMsRUFBWCxHQUE2QixNQUFELElBbk5oQixDQTRNeUIsQ0FZM0MsRUFBSzVELEtBWnNDLENBVXpCLFFBQWhCLFVBVnlDLENBWTlCLEVBQVFvRSxVQUFSLEdBWjhCLENBYVYsc0JBQXhCLE1BQVNDLElBQVQsR0Fia0MsQ0FjOUIsR0FBSUMsV0FBSixHQWQ4QixHQW1CN0MsRUFBS3JFLE9BQUwsQ0FBZSxDQW5COEIsQ0FvQjdDLEVBQUtGLFFBQUwsQ0FBZ0IsRUFBS0MsS0FBTCxDQUFXcEQsTUFwQmtCLENBc0I3QyxFQUFHLENBUUQsR0FQdUIsQ0FBbkIsS0FBSzBDLFNBT1QsR0FORSxFQUFLQyxNQUFMLENBQWMsR0FBSWQsR0FBTXNFLElBQVYsR0FNaEIsQ0FMRSxFQUFLdEQsUUFBTCxDQUFnQixDQUtsQixDQUpFLEVBQUtILFNBQUwsRUFJRixFQUZBLEVBQVN3RSxHQUFhaUQsT0FBYmpELEtBRVQsQ0FBSSxRQUEyQixNQUEvQixDQUdFLE1BRkEsTUFBS2tELEtBQUwsR0FFQSxDQURBLEtBQUtwRCxLQUFMLEdBQ0EsSUFYRCxDQWFzQixDQUFuQixLQUFLdEUsU0FBTCxFQUEyQyxDQUFsQixLQUFLUyxRQUFMLEdBQXdCLFFBQXNCLE1BQTlDLENBYjVCLElBY3lCLFFBQXBCLFFBQUtvRCxPQUFMLENBQWFLLEVBZGxCLENBZUcsS0FBS3lELE1BQUwsQ0FBWSxFQUFRQyxhQUFSLENBQXNCekksRUFBTXlFLFNBQU56RSxDQUFnQixFQUFLYyxNQUFyQmQsQ0FBNkIsRUFBS2dCLFFBQWxDaEIsQ0FBdEIsQ0FBWixDQWZILENBaUJHLEtBQUt3SSxNQUFMLENBQVl4SSxFQUFNeUUsU0FBTnpFLENBQWdCLEVBQUtjLE1BQXJCZCxDQUE2QixFQUFLZ0IsUUFBbENoQixDQUFaLENBakJILENBb0JGLENBcEJELE1Bb0JTLENBQWlCLENBQWhCLEdBQUtzQixRQUFMLEVBQXdDLENBQW5CLEtBQUtULFNBQTNCLEdBQStDLE1BcEJ4RCxFQXRCNkMsTUE2Q3pDLE9BN0N5QyxFQThDM0MsRUFBU3dFLEdBQWFxRCxVQUFickQsQ0FBd0IsS0FBS2hFLElBQTdCZ0UsQ0E5Q2tDLENBK0MzQyxLQUFLa0QsS0FBTCxHQS9DMkMsQ0FnRDNDLEtBQUtwRCxLQUFMLEdBaEQyQyxDQWlEcEMsTUFqRG9DLEVBcUR6QyxNQXJEeUMsR0FzRDNDLEtBQUtvRCxLQUFMLElBdEQyQyxDQXVEM0MsRUFBSzFILFNBQUwsQ0FBaUIsQ0F2RDBCLElBNEQ5QyxFQVlELEVBQVF3RixTQUFSLENBQWtCbUMsTUFBbEIsQ0FBMkIsV0FBaUIsQ0FDMUMsS0FBS3BELE1BQUwsQ0FBWVksSUFBWixHQUNELEVBYUQsRUFBUUssU0FBUixDQUFrQmtDLEtBQWxCLENBQTBCLFdBQWtCLENBRXRDLE1BRnNDLEdBR2hCLFFBQXBCLFFBQUs3RCxPQUFMLENBQWFLLEVBSHVCLENBSXRDLEtBQUtrQixNQUFMLENBQWMsS0FBS2IsTUFBTCxDQUFZdUQsSUFBWixDQUFpQixFQUFqQixDQUp3QixDQU10QyxLQUFLMUMsTUFBTCxDQUFjakcsRUFBTThHLGFBQU45RyxDQUFvQixLQUFLb0YsTUFBekJwRixDQU53QixFQVMxQyxLQUFLb0YsTUFBTCxHQVQwQyxDQVUxQyxLQUFLRixHQUFMLEVBVjBDLENBVzFDLEtBQUt2RSxHQUFMLENBQVcsS0FBS1UsSUFBTCxDQUFVVixHQUN0QixFQStFRCxPQVBBLGFBQThCLENBRzVCLE1BRkEsR0FBVSxLQUVWLENBREEsRUFBUXNFLElBQVIsR0FDQSxDQUFPLE1BQ1IsQ0FHRCxDTTFZQTJELEtBQUtDLFNBQUwsQ0FBaUIsV0FBZ0IsQ0FDL0IsR0FBSSxDQUNGLEdBQUksR0FBUzVELEdBQUssRUFBTTZELElBQU4sQ0FBV0EsSUFBaEI3RCxFQUFzQjhELE1BQW5DLENBQ0FILEtBQUtJLFdBQUwsQ0FBaUIsQ0FDZkMsR0FBSSxFQUFNSCxJQUFOLENBQVdHLEVBREEsQ0FFZmhELFFBRmUsQ0FBakIsQ0FJRCxDQUNELFFBQWMsQ0FDWjJDLEtBQUtJLFdBQUwsQ0FBaUIsQ0FDZkMsR0FBSSxFQUFNSCxJQUFOLENBQVdHLEVBREEsQ0FFZkMsTUFBTyxFQUFNQyxPQUZFLENBQWpCLENBSUQsQ0FDRiJ9"}